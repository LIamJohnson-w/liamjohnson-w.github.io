<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【Flink】FlinkSQL| 状态编程| 自定义函数 | SilverSucks</title><meta name="author" content="Johnson Liam"><meta name="copyright" content="Johnson Liam"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Flink 中的状态编程 在 Flink 中，算子任务可以分为无状态和有状态两种情况。 在传统的事务型处理架构中，这种额外的状态数据是保存在数据库中的。而对于实时流处理来说，这样做需要频繁读写外部数据库，如果数据规模非常大肯定就达不到性能要求了。所以 Flink 的解决方案是，将状态直接保存在内存中"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/weiswift/2023/09/12/2023.09.12/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【Flink】FlinkSQL| 状态编程| 自定义函数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-14 11:00:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><script src="/live2d-widget/autoload.js"> </script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/pic.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">217</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad"></i><span> Games</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/mikutap/"><i class="fa-fw fa fa-music"></i><span> MikuTap 初音未来</span></a></li><li><a class="site-page child" href="/starbattle/"><i class="fa-fw fa fa-space-shuttle"></i><span> StartBattle 星际大战</span></a></li><li><a class="site-page child" href="/2048/"><i class="fa-fw fa fa-flag"></i><span> 2048 经典游戏</span></a></li><li><a class="site-page child" href="/battlecity/"><i class="fa-fw fa fa-arrow-circle-left"></i><span> BattleCity 坦克大战</span></a></li><li><a class="site-page child" href="/pacman/"><i class="fa-fw fa fa-bolt"></i><span> PacMan  吃豆人</span></a></li><li><a class="site-page child" href="/tetris/"><i class="fa-fw fa fa-arrows-alt"></i><span> Tetris 俄罗斯方块</span></a></li><li><a class="site-page child" href="/smallcat/"><i class="fa-fw fa fa-paw"></i><span> CatchCat 困住小猫</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-leaf"></i><span> Moments</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/diary/"><i class="fa-fw fas fa-bookmark"></i><span> Diary</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-hourglass-half"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-podcast"></i><span> More</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags标签</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About关于</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-bookmark"></i><span> Messageboard留言板</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s1.ax1x.com/2023/04/18/p9i6u5D.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="SilverSucks"><span class="site-name">SilverSucks</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad"></i><span> Games</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/mikutap/"><i class="fa-fw fa fa-music"></i><span> MikuTap 初音未来</span></a></li><li><a class="site-page child" href="/starbattle/"><i class="fa-fw fa fa-space-shuttle"></i><span> StartBattle 星际大战</span></a></li><li><a class="site-page child" href="/2048/"><i class="fa-fw fa fa-flag"></i><span> 2048 经典游戏</span></a></li><li><a class="site-page child" href="/battlecity/"><i class="fa-fw fa fa-arrow-circle-left"></i><span> BattleCity 坦克大战</span></a></li><li><a class="site-page child" href="/pacman/"><i class="fa-fw fa fa-bolt"></i><span> PacMan  吃豆人</span></a></li><li><a class="site-page child" href="/tetris/"><i class="fa-fw fa fa-arrows-alt"></i><span> Tetris 俄罗斯方块</span></a></li><li><a class="site-page child" href="/smallcat/"><i class="fa-fw fa fa-paw"></i><span> CatchCat 困住小猫</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-leaf"></i><span> Moments</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/diary/"><i class="fa-fw fas fa-bookmark"></i><span> Diary</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-hourglass-half"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-podcast"></i><span> More</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags标签</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About关于</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-bookmark"></i><span> Messageboard留言板</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【Flink】FlinkSQL| 状态编程| 自定义函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-09-11T16:00:00.000Z" title="Created 2023-09-12 00:00:00">2023-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-09-14T03:00:53.000Z" title="Updated 2023-09-14 11:00:53">2023-09-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【Flink】FlinkSQL| 状态编程| 自定义函数"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Flink-中的状态编程"><a href="#Flink-中的状态编程" class="headerlink" title="Flink 中的状态编程"></a>Flink 中的状态编程</h1><blockquote>
<p>在 Flink 中，算子任务可以分为无状态和有状态两种情况。</p>
<p>在传统的事务型处理架构中，这种额外的状态数据是保存在数据库中的。而对于实时流处理来说，这样做需要频繁读写外部数据库，如果数据规模非常大肯定就达不到性能要求了。所以 Flink 的解决方案是，将状态直接保存在内存中来保证性能，并通过分布式扩展来提高吞吐量。</p>
</blockquote>
<p><img src="http://lesson-pic.oss-cn-hangzhou.aliyuncs.com/pics/wps1.jpg" alt="img"></p>
<p>有状态算子的一般处理流程：</p>
<ol>
<li>算子任务接收到上游发来的数据；</li>
<li>获取当前状态；</li>
<li>根据业务逻辑进行计算，更新状态；</li>
<li>得到计算结果，输出发送到下游任务。</li>
</ol>
<h2 id="状态分类"><a href="#状态分类" class="headerlink" title="状态分类"></a>状态分类</h2><p>按照由 Flink 管理还是用户自行管理，状态可以分为原始状态 ( Raw State ) 和托管状态 (Managed State)。</p>
<ul>
<li><p>原始状态：即用户自定义的 State。Flink 在做快照的时候，把整个 State 当做一个整体，需要开发者自己管理，使用 byte 数组来读写状态内容。</p>
</li>
<li><p>托管状态：是由 Flink 框架管理的 State，如 ValueState、ListState 等，其序列化和反序列化由 Flink 框架提供支持，无需用户感知、干预。通常在 DataStream 上的状态，推荐使用托管状态，一般情况下，在实现自定义算子时，才会使用到原始状态。</p>
<ul>
<li>算子状态（Operator State）：Operator State可以用在所有算子上，每个算子子任务或者说每个算子实例共享一个状态，流入这个算子子任务的数据可以访问和更新这个状态。</li>
</ul>
<p>  <img src="http://lesson-pic.oss-cn-hangzhou.aliyuncs.com/pics/image-20230904153632792.png" alt="image-20230904153632792"></p>
<ul>
<li>按键分区状态（Keyed State）：Keyed State是KeyedStream上的状态。假如输入流按照id为Key进行了keyBy分组，形成一个KeyedStream，数据流中所有id为1的数据共享一个状态，可以访问和更新这个状态，以此类推，每个Key对应一个自己的状态。</li>
</ul>
<p>  <img src="http://lesson-pic.oss-cn-hangzhou.aliyuncs.com/pics/image-20230904153609391.png" alt="image-20230904153609391"></p>
<p>  <code>无论是Keyed State还是Operator State，Flink的状态都是基于本地的，即每个算子子任务维护着这个算子子任务对应的状态存储，算子子任务之间的状态不能相互访问。	</code></p>
</li>
</ul>
<h2 id="分区状态"><a href="#分区状态" class="headerlink" title="分区状态"></a>分区状态</h2><p>State主要有三种实现，分别为ValueState、MapState和AppendingState，AppendingState又可以细分为ListState、ReducingState和AggregatingState。</p>
<h3 id="分区状态划分"><a href="#分区状态划分" class="headerlink" title="分区状态划分"></a>分区状态划分</h3><ul>
<li>值状态（ValueState）：状态中只保存一个“值”（value）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueState&lt;T&gt;本身是一个接口，源码中定义如下：</span></span><br><span class="line"><span class="comment">// 这里的 T 是泛型，表示状态的数据内容可以是任何具体的数据类型。如果想要保存一个长整型值作为状态，那么类型就是 ValueState&lt;Long&gt;。</span></span><br><span class="line"><span class="comment">// 可以在代码中读写值状态，实现对于状态的访问和更新。</span></span><br><span class="line"><span class="comment">// T value()：获取当前状态的值；</span></span><br><span class="line"><span class="comment">// update(T value)：对状态进行更新，传入的参数 value 就是要覆写的状态值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValueState</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    T <span class="title function_">value</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(T value)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在具体使用时，为了让运行时上下文清楚到底是哪个状态，还需要创建一个“状态描述器”（StateDescriptor）来提供状态的基本信息。例如源码中，ValueState 的状态描述器构造方法如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ValueStateDescriptor</span><span class="params">(String name, Class&lt;T&gt; typeClass)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, typeClass, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>列表状态（ListState）：将需要保存的数据，以列表（List）的形式组织起来。在 ListState<T>接口中同样有一个类型参数T，表示列表中数据的类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ListState 提供了一系列的方法来操作状态，使用方式与一般的List 非常相似。</span></span><br><span class="line"><span class="comment">// Iterable&lt;T&gt; get()：获取当前的列表状态，返回的是一个可迭代类型 Iterable；</span></span><br><span class="line"><span class="comment">// update(List&lt;T&gt; values)：传入一个列表values，直接对状态进行覆盖；</span></span><br><span class="line"><span class="comment">// add(T value)：在状态列表中添加一个元素 value；</span></span><br><span class="line"><span class="comment">// addAll(List&lt;T&gt; values)：向列表中添加多个元素，以列表 values 形式传入。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似地，ListState 的状态描述器就叫作 ListStateDescriptor，用法跟 ValueStateDescriptor完全一致。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>映射状态（MapState）：把一些键值对（key-value）作为状态整体保存起来，可以认为就是一组 key-value 映射的列表。对应的 MapState&lt;UK, UV&gt;接口中，就会有 UK、UV 两个泛型，分别表示保存的 key 和 value 的类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapState 提供了操作映射状态的方法，与 Map 的使用非常类似。</span></span><br><span class="line"><span class="comment">// UV get(UK key)：传入一个 key 作为参数，查询对应的 value 值；</span></span><br><span class="line"><span class="comment">// put(UK key, UV value)：传入一个键值对，更新 key 对应的 value 值；</span></span><br><span class="line"><span class="comment">// putAll(Map&lt;UK, UV&gt; map)：将传入的映射 map 中所有的键值对，全部添加到映射状态中；</span></span><br><span class="line"><span class="comment">// remove(UK key)：将指定 key 对应的键值对删除；</span></span><br><span class="line"><span class="comment">// boolean contains(UK key)：判断是否存在指定的 key，返回一个 boolean 值。</span></span><br><span class="line"><span class="comment">// 另外，MapState 也提供了获取整个映射相关信息的方法：</span></span><br><span class="line"><span class="comment">// Iterable&lt;Map.Entry&lt;UK, UV&gt;&gt; entries()：获取映射状态中所有的键值对；</span></span><br><span class="line"><span class="comment">// Iterable&lt;UK&gt; keys()：获取映射状态中所有的键（key），返回一个可迭代 Iterable 类型；</span></span><br><span class="line"><span class="comment">// Iterable&lt;UV&gt; values()：获取映射状态中所有的值（value），返回一个可迭代 Iterable类型；</span></span><br><span class="line"><span class="comment">// boolean isEmpty()：判断映射是否为空，返回一个 boolean 值。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>归约状态（ReducingState）：类似于值状态（Value），不过需要对添加进来的所有数据进行归约，将归约聚合之后的值作为状态保存下来。ReducintState<T>这个接口调用的方法类似于 ListState，只不过它保存的只是一个聚合值，所以调用.add()方法时，不是在状态列表里添加元素，而是直接把新数据和之前的状态进行归约，并用得到的结果更新状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归约逻辑的定义，是在归约状态描述器（ReducingStateDescriptor）中，通过传入一个归约函数（ReduceFunction）来实现的。这里的归约函数，就是之前介绍 reduce 聚合算子时讲到的 ReduceFunction，所以状态类型跟输入的数据类型是一样的。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReducingStateDescriptor</span><span class="params">(String name, ReduceFunction&lt;T&gt; reduceFunction, Class&lt;T&gt; typeClass)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>聚合状态（AggregatingState）：与归约状态非常类似，聚合状态也是一个值，用来保存添加进来的所有数据的聚合结果。与 ReducingState 不同的是，它的聚合逻辑是由在描述器中传入一个更加一般化的聚合函数（AggregateFunction）来定义的；里面通过一个累加器（Accumulator）来表示状态，所以聚合的状态类型可以跟添加进来的数据类型完全不同，使用更加灵活。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AggregatingState 接口调用方法也与ReducingState 相同，调用.add()方法添加元素时，会直接使用指定的AggregateFunction 进行聚合并更新状态。</span></span><br></pre></td></tr></table></figure>

<h3 id="状态生存时间"><a href="#状态生存时间" class="headerlink" title="状态生存时间"></a>状态生存时间</h3><p>在某些场景下 Flink 用户状态一直在无限增长，一些用例需要能够自动清理旧的状态。例如，作业中定义了超长的时间窗口，或者在动态表上应用了无限范围的 GROUP BY 语句。此外，目前开发人员需要自己完成 TTL 的临时实现，例如使用可能不节省存储空间的计时器服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要使用 State TTL 功能，首先要定义一个 StateTtlConfig 对象。StateTtlConfig 对象可以通过构造器模式来创建，典型地用法是传入一个 Time 对象作为 TTL 时间，然后可以设置时间处理语义(TtlTimeCharacteristic)、更新类型(UpdateType)以及状态可见性(StateVisibility)。当创建完 StateTtlConfig 对象，可以在状态描述符中启用 State TTL 功能。</span></span><br><span class="line"><span class="type">StateTtlConfig</span> <span class="variable">ttlConfig</span> <span class="operator">=</span> StateTtlConfig</span><br><span class="line">        .newBuilder(Time.seconds(<span class="number">10</span>))</span><br><span class="line">        .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)</span><br><span class="line">        .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)</span><br><span class="line">        .build();</span><br><span class="line">ValueStateDescriptor&lt;String&gt; stateDescriptor = <span class="keyword">new</span> <span class="title class_">ValueStateDescriptor</span>&lt;&gt;(<span class="string">&quot;my state&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">stateDescriptor.enableTimeToLive(ttlConfig);</span><br></pre></td></tr></table></figure>

<ul>
<li>时间处理语义</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TtlTimeCharacteristic 表示 State TTL 功能可以使用的时间处理语义：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TtlTimeCharacteristic</span> &#123;</span><br><span class="line">    ProcessingTime</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 截止到目前当前版本，只支持 ProcessingTime 时间处理语义。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过如下方法显示设置：</span></span><br><span class="line">setTtlTimeCharacteristic(StateTtlConfig.TtlTimeCharacteristic.ProcessingTime)</span><br></pre></td></tr></table></figure>

<ul>
<li>更新类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UpdateType 表示状态时间戳(上次访问时间戳)的更新时机：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UpdateType</span> &#123;</span><br><span class="line">    Disabled,</span><br><span class="line">    OnCreateAndWrite,</span><br><span class="line">    OnReadAndWrite</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果设置为 Disabled，则表示禁用 TTL 功能，状态不会过期；</span></span><br><span class="line"><span class="comment">// 如果设置为 OnCreateAndWrite，那么表示在状态创建或者每次写入时都会更新时间戳；</span></span><br><span class="line"><span class="comment">// 如果设置为 OnReadAndWrite，那么除了在状态创建和每次写入时更新时间戳外，读取状态也会更新状态的时间戳。</span></span><br><span class="line"><span class="comment">// 如果不配置默认为 OnCreateAndWrite。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过如下方法显示设置：</span></span><br><span class="line">setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)</span><br></pre></td></tr></table></figure>

<ul>
<li>状态可见性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// StateVisibility 表示状态可见性，在读取状态时是否返回过期值：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">StateVisibility</span> &#123;</span><br><span class="line">    ReturnExpiredIfNotCleanedUp,</span><br><span class="line">    NeverReturnExpired</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果设置为 ReturnExpiredIfNotCleanedUp，那么当状态值已经过期，但还未被真正清理掉，就会返回给调用方；</span></span><br><span class="line"><span class="comment">// 如果设置为 NeverReturnExpired，那么一旦状态值过期了，就永远不会返回给调用方，只会返回空状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过如下方法显示设置：</span></span><br><span class="line">setStateVisibility(StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp)</span><br><span class="line">setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>过期清理策略</p>
<ul>
<li>全量快照清理策略</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全量快照清理策略，这种策略可以在生成全量快照(Snapshot/Checkpoint)时清理过期状态，这样可以大大减小快照存储，但需要注意的是本地状态中过期数据并不会被清理。唯有当作业重启并从上一个快照恢复后，本地状态才会实际减小。如果要在 DataStream 中使用该过期请策略，请参考如下所示代码：</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.StateTtlConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.time.Time;</span><br><span class="line"></span><br><span class="line"><span class="type">StateTtlConfig</span> <span class="variable">ttlConfig</span> <span class="operator">=</span> StateTtlConfig</span><br><span class="line">        .newBuilder(Time.seconds(<span class="number">1</span>))</span><br><span class="line">        .cleanupFullSnapshot()</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>  <code>这种过期清理策略对开启了增量检查点的 RocksDB 状态后端无效。</code></p>
<ul>
<li>增量清理策略</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 Heap StateBackend 的增量清理策略。这种策略下存储后端会为所有状态条目维护一个惰性全局迭代器。每次触发增量清理时，迭代器都会向前迭代删除已遍历的过期数据。如果要在 DataStream 中使用该过期请策略，请参考如下所示代码：</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.StateTtlConfig;</span><br><span class="line"><span class="type">StateTtlConfig</span> <span class="variable">ttlConfig</span> <span class="operator">=</span> StateTtlConfig</span><br><span class="line">        .newBuilder(Time.seconds(<span class="number">1</span>))</span><br><span class="line">        .cleanupIncrementally(<span class="number">5</span>, <span class="literal">false</span>)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// 该策略有两个参数：第一个参数表示每次触发清理时需要检查的状态条目数，总是在状态访问时触发。第二个参数定义了在每次处理记录时是否额外触发清理。堆状态后端的默认后台清理每次触发检查 5 个条目，处理记录时不会额外进行过期数据清理。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>如果该状态没有被访问或者没有记录需要处理，那么过期状态会一直存在。</li>
<li>增量清理所花费的时间会增加记录处理延迟。</li>
<li>目前仅堆状态后端实现了增量清理。为 RocksDB 状态后端设置增量清理不会有任何效果。</li>
<li>如果堆状态后端与同步快照一起使用，全局迭代器在迭代时保留所有 Key 的副本，因为它的特定实现不支持并发修改。启用此功能将增加内存消耗。异步快照没有这个问题。</li>
<li>对于现有作业，可以随时在 StateTtlConfig 中启用或者停用此清理策略。</li>
</ul>
</blockquote>
<ul>
<li>RocksDB 压缩清理策略</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果使用 RocksDB StateBackend，则会调用 Flink 指定的压缩过滤器进行后台清理。RocksDB 周期性运行异步压缩来合并状态更新并减少存储。Flink 压缩过滤器使用 TTL 检查状态条目的过期时间戳并删除过期状态值。如果要在 DataStream 中使用该过期请策略，请参考如下所示代码：</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.StateTtlConfig;</span><br><span class="line"></span><br><span class="line"><span class="type">StateTtlConfig</span> <span class="variable">ttlConfig</span> <span class="operator">=</span> StateTtlConfig</span><br><span class="line">        .newBuilder(Time.seconds(<span class="number">1</span>))</span><br><span class="line">        .cleanupInRocksdbCompactFilter(<span class="number">1000</span>)</span><br><span class="line">        .build();</span><br><span class="line"><span class="comment">// RocksDB 压缩过滤器在每次处理一定状态条目后，查询当前的时间戳并检查是否过期。频繁地更新时间戳可以提高清理速度，但同样也会降低压缩性能。RocksDB 状态后端的默认每处理 1000 个条目就查询当前时间戳。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="算子状态"><a href="#算子状态" class="headerlink" title="算子状态"></a>算子状态</h2><p>算子状态（Operator State）就是一个算子并行实例上定义的状态，作用范围被限定为当前算子任务，与Key无关，不同Key的数据只要分发到同一个并行子任务，就会访问到同一个算子状态。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>算子状态一般用在 Source 或 Sink 等与外部系统连接的算子上，或者完全没有 key 定义的场景。比如 Flink 的 Kafka 连接器中，就用到了算子状态。在给 Source 算子设置并行度后，Kafka 消费者的每一个并行实例，都会为对应的主题（topic）分区维护一个偏移量， 作为算子状态保存起来。这在保证 Flink 应用“精确一次”（exactly-once）状态一致性时非常有用。</p>
<h3 id="状态类型"><a href="#状态类型" class="headerlink" title="状态类型"></a>状态类型</h3><p>算子状态也支持不同的结构类型，主要有三种：ListState、UnionListState 和 BroadcastState。</p>
<ul>
<li>列表状态（ListState）：与 Keyed State 中的 ListState 一样，将状态表示为一组数据的列表。与 Keyed State 中的列表状态的区别是：在算子状态的上下文中，不会按键（key）分别处理状态，所以每一个并行子任务上只会保留一个“列表”（list），也就是当前并行子任务上所有状态项的集合。列表中的状态项就是可以重新分配的最细粒度，彼此之间完全独立。</li>
</ul>
<blockquote>
<ul>
<li>当算子并行度进行缩放调整时，算子的列表状态中的所有元素项会被统一收集起来，相当于把多个分区的列表合并成了一个“大列表”，然后再均匀地分配给所有并行任务。这种“均匀分配”的具体方法就是“轮询”（round-robin），与之前介绍的 rebanlance 数据传输方式类似，是通过逐一“发牌”的方式将状态项平均分配的。这种方式也叫作“平均分割重组”（even-splitredistribution）。</li>
<li>算子状态中不会存在“键组”（key group）这样的结构，所以为了方便重组分配，就把它直接定义成了“列表”（list）。这也就解释了，为什么算子状态中没有最简单的值状态（ValueState）。</li>
<li>总结：ListState的快照存储数据，在系统重启后，list数据的重分配模式为： round-robin； 轮询平均分配</li>
</ul>
</blockquote>
<ul>
<li>联合列表状态（UnionListState）：与 ListState 类似，联合列表状态也会将状态表示为一个列表。它与常规列表状态的区别在于：算子并行度进行缩放调整时对于状态的分配方式不同。</li>
</ul>
<blockquote>
<ul>
<li>UnionListState 的重点就在于“联合”（union）。在并行度调整时，常规列表状态是轮询分配状态项，而联合列表状态的算子则会直接广播状态的完整列表。这样，并行度缩放之后的并行子任务就获取到了联合后完整的“大列表”，可以自行选择要使用的状态项和要丢弃的状态项。这种分配也叫作“联合重组”（union redistribution）。如果列表中状态项数量太多，为资源和效率考虑一般不建议使用联合重组的方式。</li>
<li>总结：unionListState的快照存储数据，在系统重启后，list数据的重分配模式为： 广播模式； 在每个subtask上都拥有一份完整的数据</li>
</ul>
</blockquote>
<ul>
<li>广播状态（BroadcastState）：有时希望算子并行子任务都保持同一份“全局”状态，用来做统一的配置和规则设定。这时所有分区的所有数据都会访问到同一个状态，状态就像被“广播”到所有分区一样，这种特殊的算子状态，就叫作广播状态（BroadcastState）。</li>
</ul>
<blockquote>
<ul>
<li>因为广播状态在每个并行子任务上的实例都一样，所以在并行度调整的时候就比较简单， 只要复制一份到新的并行任务就可以实现扩展；而对于并行度缩小的情况，可以将多余的并行子任务连同状态直接砍掉——因为状态都是复制出来的，并不会丢失。</li>
<li>在底层，广播状态是以类似映射结构（map）的键值对（key-value）来保存的，必须基于一个“广播流”（BroadcastStream）来创建。</li>
</ul>
</blockquote>
<h1 id="Flink-SQL常用语法"><a href="#Flink-SQL常用语法" class="headerlink" title="Flink SQL常用语法"></a>Flink SQL常用语法</h1><blockquote>
<p>主要分为DDL和DML语句</p>
</blockquote>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="DDL-Create-子句"><a href="#DDL-Create-子句" class="headerlink" title="DDL: Create 子句"></a>DDL: Create 子句</h3><blockquote>
<p>目前 Flink SQL 支持下列 CREATE 语句</p>
<p>● CREATE TABLE</p>
<p>● CREATE DATABASE</p>
<p>● CREATE VIEW</p>
<p>● CREATE FUNCTION</p>
</blockquote>
<h3 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a><strong>建表语句</strong></h3><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="DML-With-子句"><a href="#DML-With-子句" class="headerlink" title="DML: With 子句"></a>DML: With 子句</h3><h3 id="DML-WHERE-子句"><a href="#DML-WHERE-子句" class="headerlink" title="DML: WHERE 子句"></a>DML: WHERE 子句</h3><h3 id="DML-DISTINCT-子句"><a href="#DML-DISTINCT-子句" class="headerlink" title="DML: DISTINCT 子句"></a>DML: DISTINCT 子句</h3><h3 id="DML-窗口聚合"><a href="#DML-窗口聚合" class="headerlink" title="DML: 窗口聚合"></a>DML: 窗口聚合</h3><h3 id="DML-Group-聚合"><a href="#DML-Group-聚合" class="headerlink" title="DML: Group 聚合"></a>DML: Group 聚合</h3><h3 id="DML-Joins-语法"><a href="#DML-Joins-语法" class="headerlink" title="DML: Joins 语法"></a>DML: Joins 语法</h3><p>Flink 也支持了非常多的数据 Join 方式，主要包括以下三种：</p>
<ul>
<li>动态表（流）与动态表（流）的 Join</li>
<li>动态表（流）与外部维表（比如 Redis）的 Join</li>
<li>动态表字段的列转行（一种特殊的 Join）</li>
</ul>
<p>细分 Flink SQL 支持的 Join：</p>
<ul>
<li>Regular Join：流与流的 Join，包括 Inner Equal Join、Outer Equal Join</li>
</ul>
<blockquote>
<ol>
<li>实时 Regular Join 可以不是 等值 join。等值 join 和 非等值 join 区别在于，等值 join 数据 shuffle 策略是 Hash，会按照 Join on 中的等值条件作为 id 发往对应的下游；非等值 join 数据 shuffle 策略是 Global，所有数据发往一个并发，按照非等值条件进行关联</li>
<li>Join 的流程是左流新来一条数据之后，会和右流中符合条件的所有数据做 Join，然后输出。</li>
<li>流的上游是无限的数据，所以要做到关联的话，Flink 会将两条流的所有数据都存储在 State 中，所以 Flink 任务的 State 会无限增大，因此你需要为 State 配置合适的 TTL，以防止 State 过大</li>
</ol>
</blockquote>
<ul>
<li>Interval Join：流与流的 Join，两条流一段时间区间内的 Join</li>
</ul>
<blockquote>
<p>实时 Interval Join 可以不是 等值 join。等值 join 和 非等值 join 区别在于，等值 join 数据 shuffle 策略是 Hash，会按照 Join on 中的等值条件作为 id 发往对应的下游；非等值 join 数据 shuffle 策略是 Global，所有数据发往一个并发，然后将满足条件的数据进行关联输出</p>
<p><code>当左Join时如果左流中有数据没有被Join到，当这些数据之后（时间语义上的之后）的数据被Join到后，这些数据就过期了输出NUll</code></p>
</blockquote>
<ul>
<li>Temporal Join：流与流的 Join，包括事件时间，处理时间的 Temporal Join，类似于离线中的快照 Join</li>
<li>Lookup Join：流与外部维表的 Join</li>
<li>Array Expansion：表字段的列转行，类似于 Hive 的 explode 数据炸开的列转行</li>
<li>Table Function：自定义函数的表字段的列转行，支持 Inner Join 和 Left Outer Join</li>
</ul>
<h3 id="DML-集合操作"><a href="#DML-集合操作" class="headerlink" title="DML: 集合操作"></a>DML: 集合操作</h3><h3 id="DML-TopN"><a href="#DML-TopN" class="headerlink" title="DML: TopN"></a>DML: TopN</h3><h1 id="Flink-SQL-自定义函数UDF"><a href="#Flink-SQL-自定义函数UDF" class="headerlink" title="Flink SQL 自定义函数UDF"></a>Flink SQL 自定义函数UDF</h1><h2 id="函数归类"><a href="#函数归类" class="headerlink" title="函数归类"></a>函数归类</h2><p>Flink 中的函数有两个维度的归类标准。</p>
<ul>
<li>一个归类标准是：系统（内置）函数和 Catalog 函数。系统函数没有命名空间，只能通过其名称来进行引用。Catalog 函数属于 Catalog 和数据库，因此它们拥有 Catalog 和数据库的命名空间。用户可以通过全&#x2F;部分限定名（catalog.db.func 或 db.func）或者函数来对 Catalog 函数进行引用。</li>
<li>另一个归类标准是：临时函数和持久化函数。临时函数由用户创建，它仅在会话的生命周期（也就是一个 Flink 任务的一次运行生命周期内）内有效。持久化函数不是由系统提供的，是存储在 Catalog 中，它在不同会话的生命周期内都有效。</li>
</ul>
<p>这两个维度归类标准组合下，Flink SQL 总共提供了 4 种函数：</p>
<ul>
<li>临时性系统内置函数</li>
<li>系统内置函数</li>
<li>临时性 Catalog 函数（例如：Create Temporary Function）</li>
<li>Catalog 函数（例如：Create Function）</li>
</ul>
<p>请注意，在用户使用函数时，系统函数始终优先于 Catalog 函数解析，临时函数始终优先于持久化函数解析。</p>
<h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p>当前 Flink 提供了一下几种 UDF 能力：</p>
<ul>
<li>标量函数（Scalar functions 或 UDAF）：输入一条输出一条，将标量值转换成一个新标量值，对标 Hive 中的 UDF；</li>
<li>表值函数（Table functions 或 UDTF）：输入一条条输出多条，对标 Hive 中的 UDTF；</li>
<li>聚合函数（Aggregate functions 或 UDAF）：输入多条输出一条，对标 Hive 中的 UDAF；</li>
<li>表值聚合函数（Table aggregate functions 或 UDTAF）：仅仅支持 Table API，不支持 SQL API，其可以将多行转为多行；</li>
<li>异步表值函数（Async table functions）：这是一种特殊的 UDF，支持异步查询外部数据系统，用在前文介绍到的 lookup join 中作为查询外部系统的函数。</li>
</ul>
<h2 id="标量函数"><a href="#标量函数" class="headerlink" title="标量函数"></a>标量函数</h2><blockquote>
<p>继承ScalarFunction类，实现eval()方法</p>
</blockquote>
<h3 id="自定义标量函数"><a href="#自定义标量函数" class="headerlink" title="自定义标量函数"></a>自定义标量函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.flink.udf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.Table;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.bridge.java.StreamTableEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.functions.ScalarFunction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScalarFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、构建动态表运行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="type">StreamTableEnvironment</span> <span class="variable">tEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、注册UDF</span></span><br><span class="line">        tEnv.createTemporaryFunction(<span class="string">&quot;mySum&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyFunc</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、调用UDF处理数据</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">result</span> <span class="operator">=</span> tEnv.sqlQuery(<span class="string">&quot;select mySum(1, 2, 3, 45)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、输出结果并执行</span></span><br><span class="line">        tEnv.toDataStream(result).print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义标量函数进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyFunc</span> <span class="keyword">extends</span> <span class="title class_">ScalarFunction</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">eval</span><span class="params">(Integer... a)</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer i :</span><br><span class="line">                    a) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="表值函数"><a href="#表值函数" class="headerlink" title="表值函数"></a>表值函数</h2><blockquote>
<p>TableFuntion 可以有0个、一个、多个输入参数，他的返回值可以是任意行，每行可以有多列数据。</p>
<p>实现自定义TableFunction需要继承TableFunction类，实现eval方法。</p>
<ul>
<li>TableFunction是一个泛型类，需要指定返回值类型</li>
<li>不同于标量函数，eval方法没有返回值，使用collect方法来收集对象。</li>
</ul>
</blockquote>
<h3 id="自定义表值函数"><a href="#自定义表值函数" class="headerlink" title="自定义表值函数"></a>自定义表值函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.DataTypes;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.Schema;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.Table;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.bridge.java.StreamTableEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.functions.TableFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.types.Row;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.flink.api.common.typeinfo.Types.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTableFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、构建动态表运行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="type">StreamTableEnvironment</span> <span class="variable">tEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、注册函数</span></span><br><span class="line">        tEnv.createTemporaryFunction(<span class="string">&quot;mySplit&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyFunc</span>(<span class="string">&quot;u&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、调用UDF处理数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建dataStream</span></span><br><span class="line">        <span class="keyword">final</span> SingleOutputStreamOperator&lt;Row&gt; ordersDataStream = env.fromElements(</span><br><span class="line">                Row.of(<span class="number">2</span>, <span class="string">&quot;Euro&quot;</span>),</span><br><span class="line">                Row.of(<span class="number">1</span>, <span class="string">&quot;US Dollar&quot;</span>),</span><br><span class="line">                Row.of(<span class="number">50</span>, <span class="string">&quot;Yen&quot;</span>),</span><br><span class="line">                Row.of(<span class="number">3</span>, <span class="string">&quot;Euro&quot;</span>)).returns(ROW_NAMED(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;amount&quot;</span>, <span class="string">&quot;currency&quot;</span>&#125;, INT, STRING));</span><br><span class="line">        <span class="comment">// 通过已有的dataStream构建动态表</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">ordersTable</span> <span class="operator">=</span> tEnv.fromDataStream(ordersDataStream, Schema.newBuilder()</span><br><span class="line">                .column(<span class="string">&quot;amount&quot;</span>, DataTypes.INT())</span><br><span class="line">                .column(<span class="string">&quot;currency&quot;</span>, DataTypes.STRING())</span><br><span class="line">                .columnByExpression(<span class="string">&quot;proctime&quot;</span>, <span class="string">&quot;PROCTIME()&quot;</span>)</span><br><span class="line">                .build());</span><br><span class="line"></span><br><span class="line">        tEnv.createTemporaryView(<span class="string">&quot;ordersTable&quot;</span>, ordersTable);</span><br><span class="line"></span><br><span class="line">        <span class="type">Table</span> <span class="variable">result</span> <span class="operator">=</span> tEnv.sqlQuery(<span class="string">&quot;SELECT o.currency, T.word, T.length FROM ordersTable as o, LATERAL TABLE(mySplit(currency)) as T(word, length)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、输出结果</span></span><br><span class="line">        tEnv.toDataStream(result, Row.class).print(<span class="string">&quot;分词查询&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义表值函数对字符串进行切分并返回切分后的单词与单词长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyFunc</span> <span class="keyword">extends</span> <span class="title class_">TableFunction</span>&lt;Tuple2&lt;String, Integer&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sep</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyFunc</span><span class="params">(String sep)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sep = sep;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eval</span><span class="params">(String str)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s :</span><br><span class="line">                    str.split(sep)) &#123;</span><br><span class="line">                collect(Tuple2.of(s, s.length()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>Flink 的AggregateFunction是一个基于中间计算结果状态进行增量计算的函数。由于是迭代计算方式，所以，在窗口处理过程中，不用缓存整个窗口的数据，所以效率执行比较高。</p>
<p>该函数会将给定的聚合函数应用于每个窗口和键。 对每个元素调用聚合函数，以递增方式聚合值，并将每个键和窗口的状态保持在一个累加器中。</p>
<blockquote>
<p>AggregateFunction需要重写的方法有：</p>
<ul>
<li>createAccumulator：创建一个新的累加器，开始一个新的聚合。累加器是正在运行的聚合的状态。</li>
<li>add：将给定的输入添加到给定的累加器，并返回新的累加器值。</li>
<li>getResult：从累加器获取聚合结果。</li>
<li>merge：合并两个累加器，返回合并后的累加器的状态。</li>
</ul>
</blockquote>
<h3 id="自定义聚合函数"><a href="#自定义聚合函数" class="headerlink" title="自定义聚合函数"></a>自定义聚合函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.flink.udf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.AggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.bridge.java.StreamTableEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAggregateFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、构建动态表运行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="type">StreamTableEnvironment</span> <span class="variable">tEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、构建测试数据</span></span><br><span class="line">        DataStreamSource&lt;Tuple3&lt;String, String, Long&gt;&gt; tuple3 = env.fromElements(ENGLISH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、处理数据</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Double&gt; aggregate = tuple3.keyBy(t -&gt; t.f0)</span><br><span class="line">                .countWindow(<span class="number">2</span>)</span><br><span class="line">                .aggregate(<span class="keyword">new</span> <span class="title class_">MyAggFunc</span>());</span><br><span class="line"></span><br><span class="line">        aggregate.print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Tuple3[] ENGLISH = <span class="keyword">new</span> <span class="title class_">Tuple3</span>[] &#123;</span><br><span class="line">            Tuple3.of(<span class="string">&quot;class1&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">100L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;class1&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">40L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;class1&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">60L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;class2&quot;</span>, <span class="string">&quot;赵六&quot;</span>, <span class="number">20L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;class2&quot;</span>, <span class="string">&quot;小七&quot;</span>, <span class="number">30L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;class2&quot;</span>, <span class="string">&quot;小八&quot;</span>, <span class="number">50L</span>),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义聚合函数求每个班级的平均分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyAggFunc</span> <span class="keyword">implements</span></span><br><span class="line">            <span class="title class_">AggregateFunction</span>&lt;Tuple3&lt;String, String, Long&gt;, Tuple2&lt;Long, Long&gt;, Double&gt; &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化累加器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 最初的累加器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将新输入的数据与累加器进行计算</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value The value to add</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> accumulator The accumulator to add the value to</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 新的累加器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">add</span><span class="params">(Tuple3&lt;String, String, Long&gt; value, Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(accumulator.f0 + <span class="number">1</span>, accumulator.f1 + value.f2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 用总成绩除以总人数得到平均分</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> accumulator The accumulator of the aggregation</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 平均分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Double <span class="title function_">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) (accumulator.f1) / accumulator.f0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 合并累加器</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> a An accumulator to merge</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> b Another accumulator to merge</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 最终累加器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title function_">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(a.f0 + b.f0, a.f1 + b.f1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="表值聚合函数"><a href="#表值聚合函数" class="headerlink" title="表值聚合函数"></a>表值聚合函数</h2><p>表聚合，多对多，多行输入多行输出，用户定义的表聚合函数（User-Defined Table Aggregate Functions，UDTAF），可以把一个表中数据，聚合为具有多行和多列的结果表</p>
<blockquote>
<p>用户定义表聚合函数，是通过继承 TableAggregateFunction 抽象类来实现的，TableAggregateFunction 要求必须实现的方法：</p>
<ul>
<li>createAccumulator()</li>
<li>accumulate()</li>
<li>emitValue()</li>
<li>merge()</li>
</ul>
</blockquote>
<h3 id="表值聚合函数-1"><a href="#表值聚合函数-1" class="headerlink" title="表值聚合函数"></a>表值聚合函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.flink.udf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.DataTypes;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.Schema;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.Table;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.bridge.java.StreamTableEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.functions.TableAggregateFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.types.Row;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.flink.api.common.typeinfo.Types.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.flink.table.api.Expressions.$;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.apache.flink.table.api.Expressions.call;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAggTableFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1、构建动态表运行环境</span></span><br><span class="line">        <span class="type">StreamExecutionEnvironment</span> <span class="variable">env</span> <span class="operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.构建TableEnv</span></span><br><span class="line">        <span class="type">StreamTableEnvironment</span> <span class="variable">tableEnv</span> <span class="operator">=</span> StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SingleOutputStreamOperator&lt;Row&gt; ordersDataStream = env.fromElements(</span><br><span class="line">                Row.of(<span class="number">1</span>, <span class="string">&quot;Latte&quot;</span>, <span class="number">6</span>),</span><br><span class="line">                Row.of(<span class="number">1</span>,<span class="string">&quot;Milk&quot;</span>,<span class="number">3</span>),</span><br><span class="line">                Row.of(<span class="number">1</span>,<span class="string">&quot;Breve&quot;</span>,<span class="number">5</span>),</span><br><span class="line">                Row.of(<span class="number">1</span>,<span class="string">&quot;Mocha&quot;</span>,<span class="number">8</span>),</span><br><span class="line">                Row.of(<span class="number">1</span>,<span class="string">&quot;Tea&quot;</span>,<span class="number">4</span>)).returns(ROW_NAMED(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;price&quot;</span>&#125;, INT, STRING, INT));</span><br><span class="line"></span><br><span class="line">        <span class="type">Table</span> <span class="variable">table</span> <span class="operator">=</span> tableEnv.fromDataStream(ordersDataStream, Schema.newBuilder()</span><br><span class="line">                .column(<span class="string">&quot;id&quot;</span>, DataTypes.INT())</span><br><span class="line">                .column(<span class="string">&quot;name&quot;</span>, DataTypes.STRING())</span><br><span class="line">                .column(<span class="string">&quot;price&quot;</span>, DataTypes.INT())</span><br><span class="line">                .build());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、注册UDF</span></span><br><span class="line"><span class="comment">//        tEnv.createTemporaryFunction(&quot;top2&quot;, new MyFunc());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Arrays.stream(tEnv.listFunctions()).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // 4、调用UDF处理数据</span></span><br><span class="line"><span class="comment">//        Table result = table.groupBy($(&quot;id&quot;))</span></span><br><span class="line"><span class="comment">//                .flatAggregate(call(&quot;top2&quot;, $(&quot;price&quot;)).as(&quot;v&quot;, &quot;rank&quot;))</span></span><br><span class="line"><span class="comment">//                .select($(&quot;id&quot;), $(&quot;v&quot;), $(&quot;rank&quot;));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        // 5、输出结果</span></span><br><span class="line"><span class="comment">//        tEnv.toChangelogStream(result).print();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        env.execute();</span></span><br><span class="line">        tableEnv.createTemporaryFunction(<span class="string">&quot;top2&quot;</span>, <span class="keyword">new</span> <span class="title class_">MyFunc</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Table</span> <span class="variable">result</span> <span class="operator">=</span> table.groupBy($(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">                .flatAggregate(call(<span class="string">&quot;top2&quot;</span>, $(<span class="string">&quot;price&quot;</span>)).as(<span class="string">&quot;v&quot;</span>, <span class="string">&quot;rank&quot;</span>))</span><br><span class="line">                .select($(<span class="string">&quot;id&quot;</span>), $(<span class="string">&quot;v&quot;</span>), $(<span class="string">&quot;rank&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        tableEnv.toChangelogStream(result).print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">        env.execute(<span class="string">&quot;FlinkSqlUDFTableAggregateFunction&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Top2Accum</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> Integer first;</span><br><span class="line">        <span class="keyword">public</span> Integer second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyFunc</span> <span class="keyword">extends</span> <span class="title class_">TableAggregateFunction</span>&lt;Tuple2&lt;Integer, Integer&gt;, Top2Accum&gt; &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 初始化累加器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Top2Accum <span class="title function_">createAccumulator</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">Top2Accum</span> <span class="variable">top2Accum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Top2Accum</span>();</span><br><span class="line">            top2Accum.setFirst(Integer.MIN_VALUE);</span><br><span class="line">            top2Accum.setSecond(Integer.MIN_VALUE);</span><br><span class="line">            <span class="keyword">return</span> top2Accum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 比较新值与中间结果更新前两名</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> acc</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> v</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accumulate</span><span class="params">(Top2Accum acc, Integer v)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &gt; acc.getFirst()) &#123;</span><br><span class="line">                acc.setSecond(acc.getFirst());</span><br><span class="line">                acc.setFirst(v);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &gt; acc.getSecond()) &#123;</span><br><span class="line">                acc.setSecond(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将所有中间结果进行遍历合并计算</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> acc</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> iterable</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Top2Accum acc, java.lang.Iterable&lt;Top2Accum&gt; iterable)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Top2Accum acc2 : iterable) &#123;</span><br><span class="line">                accumulate(acc, acc2.getFirst());</span><br><span class="line">                accumulate(acc, acc2.getSecond());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">emitValue</span><span class="params">(Top2Accum acc, Collector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acc.getFirst() &gt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                out.collect(Tuple2.of(acc.getFirst(), <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acc.getSecond() &gt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                out.collect(Tuple2.of(acc.getSecond(), <span class="number">2</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

















</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://github.com/weiswift">Johnson Liam</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://github.com/weiswift/2023/09/12/2023.09.12/">https://github.com/weiswift/2023/09/12/2023.09.12/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Flink/">Flink</a></div><div class="post_share"><div class="social-share" data-image="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/pic.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/09/13/2023.09.13/" title="ClickHouse全面解析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">ClickHouse全面解析</div></div></a></div><div class="next-post pull-right"><a href="/2023/09/11/2023.09.11/" title="【Flink】Flink水印机制与快照机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">【Flink】Flink水印机制与快照机制</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/09/06/2023.09.06/" title="【Flink】Flink作业提交流程及Java编程模型之WordCount"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-06</div><div class="title">【Flink】Flink作业提交流程及Java编程模型之WordCount</div></div></a></div><div><a href="/2023/09/07/2023.09.07/" title="【Flink】Flink算子及分区概念"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-07</div><div class="title">【Flink】Flink算子及分区概念</div></div></a></div><div><a href="/2023/09/11/2023.09.11/" title="【Flink】Flink水印机制与快照机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-11</div><div class="title">【Flink】Flink水印机制与快照机制</div></div></a></div><div><a href="/2023/09/08/2023.09.08/" title="【Flink】FlinkSQL及Flink四大基石"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-08</div><div class="title">【Flink】FlinkSQL及Flink四大基石</div></div></a></div><div><a href="/2023/05/03/2023.04.24/" title="Java基础复习（上）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">Java基础复习（上）</div></div></a></div><div><a href="/2023/05/03/2023.04.26/" title="Java基础复习(下)双色球案例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">Java基础复习(下)双色球案例</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/pic.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Johnson Liam</div><div class="author-info__description">机器都在学习,你有什么理由不学习?</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">217</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">55</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" href="https://github.com/weiswift/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/weiswift" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1265019024@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">网站由Github服务器托管,感谢支持！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink-%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Flink 中的状态编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">状态分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.</span> <span class="toc-text">分区状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81%E5%88%92%E5%88%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">分区状态划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4"><span class="toc-number">1.2.2.</span> <span class="toc-text">状态生存时间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E5%AD%90%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">算子状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">状态类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink-SQL%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">Flink SQL常用语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DDL"><span class="toc-number">2.1.</span> <span class="toc-text">DDL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DDL-Create-%E5%AD%90%E5%8F%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">DDL: Create 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.2.</span> <span class="toc-text">建表语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DML"><span class="toc-number">2.2.</span> <span class="toc-text">DML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-With-%E5%AD%90%E5%8F%A5"><span class="toc-number">2.2.1.</span> <span class="toc-text">DML: With 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-WHERE-%E5%AD%90%E5%8F%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">DML: WHERE 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-DISTINCT-%E5%AD%90%E5%8F%A5"><span class="toc-number">2.2.3.</span> <span class="toc-text">DML: DISTINCT 子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-%E7%AA%97%E5%8F%A3%E8%81%9A%E5%90%88"><span class="toc-number">2.2.4.</span> <span class="toc-text">DML: 窗口聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-Group-%E8%81%9A%E5%90%88"><span class="toc-number">2.2.5.</span> <span class="toc-text">DML: Group 聚合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-Joins-%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.6.</span> <span class="toc-text">DML: Joins 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.7.</span> <span class="toc-text">DML: 集合操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DML-TopN"><span class="toc-number">2.2.8.</span> <span class="toc-text">DML: TopN</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Flink-SQL-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0UDF"><span class="toc-number">3.</span> <span class="toc-text">Flink SQL 自定义函数UDF</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BD%92%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">函数归类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">自定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">标量函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%87%E9%87%8F%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">自定义标量函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">表值函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">自定义表值函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">聚合函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.1.</span> <span class="toc-text">自定义聚合函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%80%BC%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">表值聚合函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%80%BC%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-1"><span class="toc-number">3.6.1.</span> <span class="toc-text">表值聚合函数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/18/FlinkSQL%E7%AC%94%E8%AE%B0/" title="FlinkSQL">FlinkSQL</a><time datetime="2024-09-17T16:00:00.000Z" title="Created 2024-09-18 00:00:00">2024-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/02/2024.09.02/" title="【安卓逆向】环境搭建">【安卓逆向】环境搭建</a><time datetime="2024-09-01T16:00:00.000Z" title="Created 2024-09-02 00:00:00">2024-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/12/2024.08.12/" title="【Pandas】掌管数据挖掘的神">【Pandas】掌管数据挖掘的神</a><time datetime="2024-08-11T16:00:00.000Z" title="Created 2024-08-12 00:00:00">2024-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/08/2024.08.08/" title="【MarkDown】Latex语法">【MarkDown】Latex语法</a><time datetime="2024-08-07T16:00:00.000Z" title="Created 2024-08-08 00:00:00">2024-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/02/2024.08.02/" title="【Numpy】高效科学计算">【Numpy】高效科学计算</a><time datetime="2024-08-01T16:00:00.000Z" title="Created 2024-08-02 00:00:00">2024-08-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Johnson Liam</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 小威の <a target="_blank" rel="noopener" href="https://www.cnblogs.com/liam-sliversucks/">Blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>