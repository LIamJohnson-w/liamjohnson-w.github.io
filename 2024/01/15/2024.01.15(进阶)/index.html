<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java进阶(全) | SilverSucks</title><meta name="author" content="Johnson Liam"><meta name="copyright" content="Johnson Liam"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="想写几篇短的,奈何短篇文章确实不利于之后的翻阅, 以及工作上效率的提升.考虑到这点, 于是乎将所有的Java进阶的内容全部放到一篇文章中了, 其实前面也有零零散散的写过一些进阶的和基础的文章.  Tag: Java | SilverSucks (weiswift.github.io)  一些话想对"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://liamjohnson-w.github.io/2024/01/15/2024.01.15(%E8%BF%9B%E9%98%B6)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java进阶(全)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-10 22:34:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"> <script src="/live2d-widget/autoload.js"></script><script src="/live2d-widget/autoload.js"> </script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/pic.webp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">224</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad"></i><span> Games</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/mikutap/"><i class="fa-fw fa fa-music"></i><span> MikuTap 初音未来</span></a></li><li><a class="site-page child" href="/starbattle/"><i class="fa-fw fa fa-space-shuttle"></i><span> StartBattle 星际大战</span></a></li><li><a class="site-page child" href="/2048/"><i class="fa-fw fa fa-flag"></i><span> 2048 经典游戏</span></a></li><li><a class="site-page child" href="/battlecity/"><i class="fa-fw fa fa-arrow-circle-left"></i><span> BattleCity 坦克大战</span></a></li><li><a class="site-page child" href="/pacman/"><i class="fa-fw fa fa-bolt"></i><span> PacMan  吃豆人</span></a></li><li><a class="site-page child" href="/tetris/"><i class="fa-fw fa fa-arrows-alt"></i><span> Tetris 俄罗斯方块</span></a></li><li><a class="site-page child" href="/smallcat/"><i class="fa-fw fa fa-paw"></i><span> CatchCat 困住小猫</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-leaf"></i><span> Moments</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/diary/"><i class="fa-fw fas fa-bookmark"></i><span> Diary</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-hourglass-half"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-podcast"></i><span> More</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags标签</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About关于</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-bookmark"></i><span> Messageboard留言板</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wei-blog.oss-cn-beijing.aliyuncs.com/img/bk.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="SilverSucks"><span class="site-name">SilverSucks</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad"></i><span> Games</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/mikutap/"><i class="fa-fw fa fa-music"></i><span> MikuTap 初音未来</span></a></li><li><a class="site-page child" href="/starbattle/"><i class="fa-fw fa fa-space-shuttle"></i><span> StartBattle 星际大战</span></a></li><li><a class="site-page child" href="/2048/"><i class="fa-fw fa fa-flag"></i><span> 2048 经典游戏</span></a></li><li><a class="site-page child" href="/battlecity/"><i class="fa-fw fa fa-arrow-circle-left"></i><span> BattleCity 坦克大战</span></a></li><li><a class="site-page child" href="/pacman/"><i class="fa-fw fa fa-bolt"></i><span> PacMan  吃豆人</span></a></li><li><a class="site-page child" href="/tetris/"><i class="fa-fw fa fa-arrows-alt"></i><span> Tetris 俄罗斯方块</span></a></li><li><a class="site-page child" href="/smallcat/"><i class="fa-fw fa fa-paw"></i><span> CatchCat 困住小猫</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-leaf"></i><span> Moments</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/diary/"><i class="fa-fw fas fa-bookmark"></i><span> Diary</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-hourglass-half"></i><span> Gallery</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-podcast"></i><span> More</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags标签</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About关于</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fas fa-bookmark"></i><span> Messageboard留言板</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java进阶(全)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-01-14T16:00:00.000Z" title="Created 2024-01-15 00:00:00">2024-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-04-10T14:34:14.000Z" title="Updated 2024-04-10 22:34:14">2024-04-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java进阶(全)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>想写几篇短的,奈何短篇文章确实不利于之后的翻阅, 以及工作上效率的提升.考虑到这点, 于是乎将所有的Java进阶的内容全部放到一篇文章中了, 其实前面也有零零散散的写过一些进阶的和基础的文章.</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://weiswift.github.io/tags/Java/page/2/">Tag: Java | SilverSucks (weiswift.github.io)</a></li>
</ul>
<p>一些话想对自己以及朋友们分享：</p>
<p>苏格拉底曾说过：“未经审视的人生，是不值得过的”。</p>
<p>他老人家是想表达：生活，不是通过世俗的物质方式去度过，而是要透过理性，审视人的生命的<code>终极需求</code>，从而引导出一种新的生活态度。</p>
<p>哲学角度有点高，也不是所有人每天都会去思考生命的终极需求。但不可否认的是，我们的人生，的确需要审视！</p>
</blockquote>
<p>好啦，开始本篇进阶教程；首先进阶的最重要的就是面向对象以及面向接口编程思想.</p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><blockquote>
<p>面向对象的三大主要特性就是封装, 继承, 多态.</p>
<p>在面向对象之前,还有几个关键字.</p>
</blockquote>
<h2 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h2><blockquote>
<p>Static可以修饰成员变量,成员方法, 代码块</p>
<ul>
<li>Static修饰成员变量的时候:该变量作为类变量, 被所有的对象所共享.应用场景为计数器</li>
<li>Static修饰成员方法的时候: 该方法作为静态方法, 可以通过类名.方法名 的形式直接调用, 避免了创建对象造成的内存浪费</li>
<li>Static修饰代码块的时候: 该代码块作为静态代码块会随着类的加载而加载, 一般用于给类变量赋值.<ul>
<li>与静态代码块向对应的是实例代码块, 作用和构造器是一样的, 都是用来给实例对象初始化.</li>
</ul>
</li>
</ul>
</blockquote>
<p>参考链接</p>
<ul>
<li><a href="https://liamjohnson-w.github.io/2024/01/03/2024.01.03/">【Java进阶】Static食用方式（一）</a></li>
<li><a href="https://liamjohnson-w.github.io/2024/01/04/2024.01.04/">【Java进阶】Static食用方式（二）</a></li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>继承就是将相同的内容合并到一个父类中, 简化了代码<code>提高了代码的复用性</code></p>
<p>封装就是将成员变量私有化, 提高了代码的安全性</p>
</blockquote>
<p>参考链接:</p>
<p><a href="https://liamjohnson-w.github.io/2024/01/06/2024.01.06/">【Java进阶】继承及应用场景 | 书下酒云赠人 (liamjohnson-w.github.io)</a></p>
<p><a href="https://liamjohnson-w.github.io/2024/01/07/2024.01.07/">【Java进阶】继承之方法的重写 | 书下酒云赠人 (liamjohnson-w.github.io)</a></p>
<h2 id="接口和多态"><a href="#接口和多态" class="headerlink" title="接口和多态"></a>接口和多态</h2><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>To be continue…..</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>To be continue…..</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p>To be continue…..</p>
<h1 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h1><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>是java编写的一个专门用于字符串拼接的类,可以当成一个字符串拼接的容器使用,提供了对容器中的数据进行<code>增删改</code>的功能,并提升了字符串的<code>拼接效率</code>;</p>
</blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>提供了字符串拼接,反转,修改内容的方法,弥补了字符串对象<code>不能修改内容</code>的缺点;</li>
<li><code>提升了字符串拼接的效率</code>;</li>
</ol>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ul>
<li>由于类中的方法都是非静态的，而且字符串工具，你没有个对象调什么方法，所以还是老老实实造对象吧。</li>
</ul>
<ol>
<li>利用构造方法创建对象;</li>
<li>面向创建好的对象直接调用类中的方法即可;</li>
</ol>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><blockquote>
<p>方法介绍</p>
<ul>
<li>空参，全参构造</li>
<li>append(任意类型)：将任意的数据类型追加到StringBuilder对象的末尾并返回对象本身</li>
<li>reverse()：反转sb对象</li>
<li>对象名.length()：返回对象的长度</li>
<li>对象名.toString()：将StringBuilder对象转为String基本数据类型</li>
</ul>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124213045106.png" alt="image-20240124213045106"></p>
<h3 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习 StringBuilder入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderCourse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 利用空参的构造方法创建对象</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 2, 拼接数据</span></span><br><span class="line">        sb.append(<span class="number">123</span>);</span><br><span class="line">        sb.append(<span class="literal">true</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;heihei&quot;</span>);</span><br><span class="line">        sb.append(<span class="number">5.6</span>);</span><br><span class="line">        sb.append(<span class="string">&#x27;好&#x27;</span>);</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        <span class="comment">// 3, 反转内容</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="StringBuilder应用场景"><a href="#StringBuilder应用场景" class="headerlink" title="StringBuilder应用场景"></a>StringBuilder应用场景</h2><blockquote>
<p>StringBuilder的两个常见的应用场景为：</p>
<ul>
<li>拼接数组中的元素</li>
<li>判断某个字符串是否为对称字符串</li>
</ul>
</blockquote>
<h3 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h3><blockquote>
<p>说实话：Python中一行代码顶Java100行，下面代码等于一句<code>&#39;,&#39;.join(list)</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    自定义一个方法，完成对数组内容按指定格式拼接的功能</span></span><br><span class="line"><span class="comment">    Analysis：</span></span><br><span class="line"><span class="comment">        参数：需要的数组</span></span><br><span class="line"><span class="comment">        返回值：结果字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringBuilderExample1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">// String s = toString(arr);</span></span><br><span class="line">        <span class="comment">// 下面使用的是工具类，可以理解为不需要造对象直接调用，所以要用Static关键字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> toString(arr);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toString</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">// 0：对参数进行健壮性校验</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1，提前准备一个StringBuilder用于拼接数据</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="comment">// 2，循环拼接数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 3, 先拼接数据</span></span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">            <span class="comment">// 4, 判断是否为最后一个元素，如果是则加上]</span></span><br><span class="line">            <span class="keyword">if</span> (i != arr.length -<span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个方法，判断一个字符串是否是对称字符串</span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">        参数：需要的字符串</span></span><br><span class="line"><span class="comment">        返回值：返回布尔类型的值boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgeSymmetry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;accd&quot;</span>;</span><br><span class="line">        System.out.println(symmetry(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">symmetry</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">// 1,为了将字符串s进行反转，需要将s转为StringBuilder类型</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">newSb</span> <span class="operator">=</span> sb.reverse();</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> newSb.toString();</span><br><span class="line">        <span class="keyword">if</span> (newStr.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>是java8提供的一个专门针对有规律的字符串拼接的一个类;</p>
</blockquote>
<h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol>
<li>能保证字符串的拼接效率;</li>
<li>能保证拼接字符串的简洁度;</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>只能针对字符串或字符串缓冲区拼接;</li>
<li>必须保证要拼接的结果是有规律的!</li>
</ol>
<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><p>跟StringBuilder类的方法区别就在于StringBuilder 添加元素是append，而StringJoiner是add</p>
<blockquote>
<ul>
<li>空参，全参构造方法</li>
<li>add(基本数据类型的数据)：添加数据，类似于StringBuilder中的append</li>
<li>length：这个不多说了</li>
<li>toString：这个是个Stringxxx的方法都支持的吧</li>
</ul>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124214319741.png" alt="image-20240124214319741"></p>
<h3 id="代码案例-1"><a href="#代码案例-1" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    定义一个方法，判断一个字符串是否是对称字符串</span></span><br><span class="line"><span class="comment">    分析：</span></span><br><span class="line"><span class="comment">        参数：需要的字符串</span></span><br><span class="line"><span class="comment">        返回值：返回布尔类型的值boolean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JudgeSymmetry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;accd&quot;</span>;</span><br><span class="line">        System.out.println(symmetry(s));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">symmetry</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">// 1,为了将字符串s进行反转，需要将s转为StringBuilder类型</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">newSb</span> <span class="operator">=</span> sb.reverse();</span><br><span class="line">        <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> newSb.toString();</span><br><span class="line">        <span class="keyword">if</span> (newStr.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>java提供的专门进行数学运算的工具类;<code>所有方法都是静态方法,通过类名直接调用即可</code>;</p>
</blockquote>
<h3 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h3><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124214648920.png" alt="image-20240124214648920" style="zoom:67%;" />

<h3 id="代码案例-2"><a href="#代码案例-2" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMath</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Math中的工具方法练习（直接通过类名.方法名调用）</span></span><br><span class="line">        System.out.println(Math.abs(-<span class="number">5</span>));  <span class="comment">// 5</span></span><br><span class="line">        <span class="comment">// 向上取整</span></span><br><span class="line">        System.out.println(Math.ceil(<span class="number">3.01</span>));  <span class="comment">// 4.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下取整</span></span><br><span class="line">        System.out.println(Math.floor(<span class="number">5.9</span>));  <span class="comment">// 5.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四舍五入</span></span><br><span class="line">        System.out.println(Math.round(<span class="number">5.5</span>));  <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取两个int值中的较大值</span></span><br><span class="line">        System.out.println(Math.max(<span class="number">5.0</span>,-<span class="number">4</span>));  <span class="comment">// 5.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回a的b次幂</span></span><br><span class="line">        System.out.println(Math.pow(<span class="number">2</span>, <span class="number">3</span>));  <span class="comment">// 8.0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回职位double的随机值，范围在0.0 - 1.0之间</span></span><br><span class="line">        System.out.println(Math.random());  <span class="comment">// 0.5404016363759777</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="System"><a href="#System" class="headerlink" title="System"></a>System</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>专门用于描述系统相关操作的工具类,里面所有的方法都是静态的!</p>
</blockquote>
<h3 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124214850660.png" alt="image-20240124214850660" style="zoom:67%;" />da</p>
<h3 id="代码案例-3"><a href="#代码案例-3" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习系统工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘿嘿&quot;</span>);</span><br><span class="line">        <span class="comment">//System.exit(0); // 直接退出虚拟机</span></span><br><span class="line">        System.out.println(<span class="string">&quot;看看能执行吗&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取当前时间毫秒值</span></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>与当前程序应用环境相关的工具类,获取对象的时候,利用 静态的getRuntime()方法,获取对象后,利用对象调用成员方法;</p>
</blockquote>
<h3 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124215012039.png" alt="image-20240124215012039"></p>
<h3 id="代码案例-4"><a href="#代码案例-4" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRuntime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1, 获取当前程序的系统运行对象</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2, 查看CPU核数</span></span><br><span class="line">        System.out.println(r.availableProcessors());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 获取Java虚拟机的总内存和可用内存</span></span><br><span class="line">        System.out.println(r.totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(r.freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4, 调用系统中的第三方程序(这里必须在主程序入口抛出 IOException)</span></span><br><span class="line">        <span class="comment">// 打开记事本</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> r.exec(<span class="string">&quot;notepad&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入任意内容，让程序继续执行！&quot;</span>);</span><br><span class="line">        sc.next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5, 通过process 对象，关闭记事本</span></span><br><span class="line">        process.destroy();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>java编写的专门用于精确运算的类;</p>
</blockquote>
<h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>对小数可以完成<code>精确运算</code>;</p>
<h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li>创建对象</li>
<li>调用方法</li>
</ol>
<h3 id="获取对象的方式"><a href="#获取对象的方式" class="headerlink" title="获取对象的方式"></a>获取对象的方式</h3><ul>
<li>方式一：利用构造方法;<ul>
<li><code>public BigDecimal(String val)  -- 把String变成BigDecimal</code></li>
</ul>
</li>
<li>方式二：利用静态方法;<ul>
<li><code>public static BigDecimal valueOf(double val)  -- 把double类型的变量变成BigDecimal</code></li>
</ul>
</li>
</ul>
<h3 id="常用成员方法（必须要有对象"><a href="#常用成员方法（必须要有对象" class="headerlink" title="常用成员方法（必须要有对象"></a>常用成员方法（必须要有对象</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124215528590.png" alt="image-20240124215528590"></p>
<h3 id="代码案例-5"><a href="#代码案例-5" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBigDecimal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果使用double直接运算，会出现进度损失的现象，应该使用BigDecimal进行精确运算</span></span><br><span class="line">        System.out.println(<span class="number">0.2</span> + <span class="number">0.1</span>);  <span class="comment">// 0.30000000000000004 出现了精度损失</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1, 创建两个BigDecimal对象</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2, 使用其中一个对象调用add方法，传递另一个对象就可以完成相加的操作了</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">add</span> <span class="operator">=</span> bd1.add(bd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 面向add对象，获取里面保存的数据</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">v</span> <span class="operator">=</span> add.doubleValue();</span><br><span class="line">        System.out.println(v);  <span class="comment">// 0.3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 练习减 操作</span></span><br><span class="line">        System.out.println(bd1.subtract(bd2).doubleValue());</span><br><span class="line">        <span class="comment">// 练习乘除 操作</span></span><br><span class="line">        System.out.println(bd1.multiply(bd2).doubleValue());</span><br><span class="line">        System.out.println(bd1.divide(bd2).doubleValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Notice-divide方法除不尽情况"><a href="#Notice-divide方法除不尽情况" class="headerlink" title="Notice: divide方法除不尽情况"></a>Notice: divide方法除不尽情况</h2><blockquote>
<p>可以在divide方法中传递3个参数,第1个参数是除数,第2个参数是保留的小数位数,第3个参数是java写好的枚举类中罗列的舍入模式;</p>
<p><code>比较常见的舍入模式有3个:UP, DOWN, HALF_UP</code><br>Tips: RoundingMode(枚举类名)</p>
</blockquote>
<h3 id="CodeDemo"><a href="#CodeDemo" class="headerlink" title="CodeDemo"></a>CodeDemo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBigDecimal_pro</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1: 创建两个BigDecimal对象</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;0.2&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">0.3</span>);</span><br><span class="line">        <span class="comment">// 2: 当除不尽的时候,向上取整,保留3位小数</span></span><br><span class="line">        <span class="comment">//BigDecimal divide = bd1.divide(bd2, 3, RoundingMode.UP);</span></span><br><span class="line">        <span class="comment">// 向下取整</span></span><br><span class="line">        <span class="comment">//BigDecimal divide = bd1.divide(bd2, 3, RoundingMode.DOWN);</span></span><br><span class="line">        <span class="comment">// 四舍五入</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">divide</span> <span class="operator">=</span> bd1.divide(bd2, <span class="number">3</span>, RoundingMode.HALF_UP);</span><br><span class="line">        System.out.println(divide.doubleValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JDk7日期"><a href="#JDk7日期" class="headerlink" title="JDk7日期"></a>JDk7日期</h2><h3 id="Date概述"><a href="#Date概述" class="headerlink" title="Date概述"></a>Date概述</h3><blockquote>
<p>是java7以前提供的用于表示时间点的类,以1970年1月1日0点0分0秒为时间原点;</p>
<p>里面很多方法都被废弃了。</p>
</blockquote>
<h3 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124220315185.png" alt="image-20240124220315185"></p>
<h3 id="代码案例-6"><a href="#代码案例-6" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建当前时间点对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将日期转成本地日期格式</span></span><br><span class="line">        System.out.println(d.toLocaleString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2, 创建指定毫秒值得时间点对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(-<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>);</span><br><span class="line">        System.out.println(d1.toLocaleString());</span><br><span class="line"></span><br><span class="line">        System.out.println(d1.getTime());</span><br><span class="line">        System.out.println(d.getTime());</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK7的日期格式化工具类"><a href="#JDK7的日期格式化工具类" class="headerlink" title="JDK7的日期格式化工具类"></a>JDK7的日期格式化工具类</h2><h3 id="SimpleDateFormat概述"><a href="#SimpleDateFormat概述" class="headerlink" title="SimpleDateFormat概述"></a>SimpleDateFormat概述</h3><blockquote>
<p>是java专门针对Date类提供的工具类;可以将Date和字符串之间进行相互转换!</p>
</blockquote>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><ol>
<li>创建工具对象;(一般会指定字符串的格式,既模式字符串)</li>
<li>使用工具对象,调用方法,即可完成字符串和Date的相互转换;</li>
</ol>
<h3 id="常用方法-6"><a href="#常用方法-6" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将Date转成字符串,这个过程叫做格式化;对应的方法名: format(日期对象);</span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将字符串转成Date,这个过程叫做解析;对应的方法名: parse(字符串);</span><br></pre></td></tr></table></figure>

<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124221316324.png" alt="image-20240124221316324"></p>
<h2 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>是java7提供的一个用于表示日历的类,可以对时间进行推移运算;</p>
</blockquote>
<h3 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li>利用静态方法获取对象;</li>
<li>面向对象,调用方法;</li>
</ol>
<h3 id="常用方法-7"><a href="#常用方法-7" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124221404649.png" alt="image-20240124221404649"></p>
<h3 id="代码案例-7"><a href="#代码案例-7" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 获取一个日历对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">ins</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 2, 面向日历获取信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ins.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ins.get(Calendar.MONTH);  <span class="comment">// 获取的是月份对应的索引（1月为0，12月为11</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> ins.get(Calendar.DATE);</span><br><span class="line">        System.out.println(<span class="string">&quot;年份为：&quot;</span> + y + <span class="string">&quot;; 月份为：&quot;</span> + m + <span class="string">&quot;; 日期为：&quot;</span> + d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 对时间进行推移</span></span><br><span class="line">        ins.add(Calendar.MONTH, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(ins.get(Calendar.MONTH));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h1><h2 id="JDk7日期-1"><a href="#JDk7日期-1" class="headerlink" title="JDk7日期"></a>JDk7日期</h2><h3 id="Date概述-1"><a href="#Date概述-1" class="headerlink" title="Date概述"></a>Date概述</h3><blockquote>
<p>是java7以前提供的用于表示时间点的类,以1970年1月1日0点0分0秒为时间原点;</p>
<p>里面很多方法都被废弃了。</p>
</blockquote>
<h3 id="常用方法-8"><a href="#常用方法-8" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124220315185.png" alt="image-20240124220315185"></p>
<h3 id="代码案例-8"><a href="#代码案例-8" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建当前时间点对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将日期转成本地日期格式</span></span><br><span class="line">        System.out.println(d.toLocaleString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2, 创建指定毫秒值得时间点对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(-<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">7</span>);</span><br><span class="line">        System.out.println(d1.toLocaleString());</span><br><span class="line"></span><br><span class="line">        System.out.println(d1.getTime());</span><br><span class="line">        System.out.println(d.getTime());</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JDK7的日期格式化工具类-1"><a href="#JDK7的日期格式化工具类-1" class="headerlink" title="JDK7的日期格式化工具类"></a>JDK7的日期格式化工具类</h2><h3 id="SimpleDateFormat概述-1"><a href="#SimpleDateFormat概述-1" class="headerlink" title="SimpleDateFormat概述"></a>SimpleDateFormat概述</h3><blockquote>
<p>是java专门针对Date类提供的工具类;可以将Date和字符串之间进行相互转换!</p>
</blockquote>
<h3 id="如何使用-1"><a href="#如何使用-1" class="headerlink" title="如何使用"></a>如何使用</h3><ol>
<li>创建工具对象;(一般会指定字符串的格式,既模式字符串)</li>
<li>使用工具对象,调用方法,即可完成字符串和Date的相互转换;</li>
</ol>
<h3 id="常用方法-9"><a href="#常用方法-9" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="格式化-1"><a href="#格式化-1" class="headerlink" title="格式化"></a>格式化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将Date转成字符串,这个过程叫做格式化;对应的方法名: format(日期对象);</span><br></pre></td></tr></table></figure>

<h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将字符串转成Date,这个过程叫做解析;对应的方法名: parse(字符串);</span><br></pre></td></tr></table></figure>

<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124221316324.png" alt="image-20240124221316324"></p>
<h2 id="Calendar-1"><a href="#Calendar-1" class="headerlink" title="Calendar"></a>Calendar</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>是java7提供的一个用于表示日历的类,可以对时间进行推移运算;</p>
</blockquote>
<h3 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h3><ol>
<li>利用静态方法获取对象;</li>
<li>面向对象,调用方法;</li>
</ol>
<h3 id="常用方法-10"><a href="#常用方法-10" class="headerlink" title="常用方法"></a>常用方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240124221404649.png" alt="image-20240124221404649"></p>
<h3 id="代码案例-9"><a href="#代码案例-9" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 获取一个日历对象</span></span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">ins</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        <span class="comment">// 2, 面向日历获取信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ins.get(Calendar.YEAR);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> ins.get(Calendar.MONTH);  <span class="comment">// 获取的是月份对应的索引（1月为0，12月为11</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> ins.get(Calendar.DATE);</span><br><span class="line">        System.out.println(<span class="string">&quot;年份为：&quot;</span> + y + <span class="string">&quot;; 月份为：&quot;</span> + m + <span class="string">&quot;; 日期为：&quot;</span> + d);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 对时间进行推移</span></span><br><span class="line">        ins.add(Calendar.MONTH, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(ins.get(Calendar.MONTH));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JDK7和8日期类比较"><a href="#JDK7和8日期类比较" class="headerlink" title="JDK7和8日期类比较"></a>JDK7和8日期类比较</h2><blockquote>
<p>JDK8新增的日期类分得更细致一些，比如表示年月日用LocalDate类、表示时间秒用LocalTime类、而表示年月日时分秒用LocalDateTime类等；除了这些类还提供了对时区、时间间隔进行操作的类等，用起来特别方便。</p>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240127172344465.png" alt="image-20240127172344465"></p>
<h3 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240127173048482.png" alt="image-20240127173048482"></p>
<h2 id="JDK8日期"><a href="#JDK8日期" class="headerlink" title="JDK8日期"></a>JDK8日期</h2><blockquote>
<p>Notes: 这里part1,2,3,4是上图中的四大模块。</p>
</blockquote>
<h3 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h3><blockquote>
<p>LocalDate、LocalTime、以及LocalDateTime类。这三个类的用法基本大同小异，由于我之前偷懒就写了一个Demo，这里就copy一下别人的代码。</p>
</blockquote>
<h4 id="LocalDate类的基本使用"><a href="#LocalDate类的基本使用" class="headerlink" title="LocalDate类的基本使用"></a>LocalDate类的基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1_LocalDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地日期对象(不可变对象)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now(); <span class="comment">// 年 月 日</span></span><br><span class="line">        System.out.println(ld);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取日期对象中的信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> ld.getYear(); <span class="comment">// 年</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> ld.getMonthValue(); <span class="comment">// 月(1-12)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> ld.getDayOfMonth(); <span class="comment">// 日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> ld.getDayOfYear();  <span class="comment">// 一年中的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> ld.getDayOfWeek().getValue(); <span class="comment">// 星期几</span></span><br><span class="line">        System.out.println(year);</span><br><span class="line">        System.out.println(day);</span><br><span class="line">        System.out.println(dayOfWeek);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、直接修改某个信息: withYear、withMonth、withDayOfMonth、withDayOfYear</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld2</span> <span class="operator">=</span> ld.withYear(<span class="number">2099</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld3</span> <span class="operator">=</span> ld.withMonth(<span class="number">12</span>);</span><br><span class="line">        System.out.println(ld2);</span><br><span class="line">        System.out.println(ld3);</span><br><span class="line">        System.out.println(ld);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、把某个信息加多少: plusYears、plusMonths、plusDays、plusWeeks</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld4</span> <span class="operator">=</span> ld.plusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld5</span> <span class="operator">=</span> ld.plusMonths(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、把某个信息减多少：minusYears、minusMonths、minusDays、minusWeeks</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld6</span> <span class="operator">=</span> ld.minusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld7</span> <span class="operator">=</span> ld.minusMonths(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定日期的LocalDate对象： public static LocalDate of(int year, int month, int dayOfMonth)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld8</span> <span class="operator">=</span> LocalDate.of(<span class="number">2099</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld9</span> <span class="operator">=</span> LocalDate.of(<span class="number">2099</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、判断2个日期对象，是否相等，在前还是在后： equals isBefore isAfter</span></span><br><span class="line">        System.out.println(ld8.equals(ld9));<span class="comment">// true</span></span><br><span class="line">        System.out.println(ld8.isAfter(ld)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(ld8.isBefore(ld)); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LocalTime类的基本使用"><a href="#LocalTime类的基本使用" class="headerlink" title="LocalTime类的基本使用"></a>LocalTime类的基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2_LocalTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地时间对象</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> LocalTime.now(); <span class="comment">// 时 分 秒 纳秒 不可变的</span></span><br><span class="line">        System.out.println(lt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、获取时间中的信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> lt.getHour(); <span class="comment">//时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> lt.getMinute(); <span class="comment">//分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> lt.getSecond(); <span class="comment">//秒</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> lt.getNano(); <span class="comment">//纳秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、修改时间：withHour、withMinute、withSecond、withNano</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt3</span> <span class="operator">=</span> lt.withHour(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt4</span> <span class="operator">=</span> lt.withMinute(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt5</span> <span class="operator">=</span> lt.withSecond(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt6</span> <span class="operator">=</span> lt.withNano(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、加多少：plusHours、plusMinutes、plusSeconds、plusNanos</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt7</span> <span class="operator">=</span> lt.plusHours(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt8</span> <span class="operator">=</span> lt.plusMinutes(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt9</span> <span class="operator">=</span> lt.plusSeconds(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt10</span> <span class="operator">=</span> lt.plusNanos(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、减多少：minusHours、minusMinutes、minusSeconds、minusNanos</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt11</span> <span class="operator">=</span> lt.minusHours(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt12</span> <span class="operator">=</span> lt.minusMinutes(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt13</span> <span class="operator">=</span> lt.minusSeconds(<span class="number">10</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt14</span> <span class="operator">=</span> lt.minusNanos(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定时间的LocalTime对象：</span></span><br><span class="line">        <span class="comment">// public static LocalTime of(int hour, int minute, int second)</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt15</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt16</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、判断2个时间对象，是否相等，在前还是在后： equals isBefore isAfter</span></span><br><span class="line">        System.out.println(lt15.equals(lt16)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(lt15.isAfter(lt)); <span class="comment">// false</span></span><br><span class="line">        System.out.println(lt15.isBefore(lt)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LocalDateTime类的基本使用"><a href="#LocalDateTime类的基本使用" class="headerlink" title="LocalDateTime类的基本使用"></a>LocalDateTime类的基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3_LocalDateTime</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 0、获取本地日期和时间对象。</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">// 年 月 日 时 分 秒 纳秒</span></span><br><span class="line">        System.out.println(ldt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、可以获取日期和时间的全部信息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> ldt.getYear(); <span class="comment">// 年</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> ldt.getMonthValue(); <span class="comment">// 月</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> ldt.getDayOfMonth(); <span class="comment">// 日</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfYear</span> <span class="operator">=</span> ldt.getDayOfYear();  <span class="comment">// 一年中的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> ldt.getDayOfWeek().getValue();  <span class="comment">// 获取是周几</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> ldt.getHour(); <span class="comment">//时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> ldt.getMinute(); <span class="comment">//分</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> ldt.getSecond(); <span class="comment">//秒</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> ldt.getNano(); <span class="comment">//纳秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、修改时间信息：</span></span><br><span class="line">        <span class="comment">// withYear withMonth withDayOfMonth withDayOfYear withHour</span></span><br><span class="line">        <span class="comment">// withMinute withSecond withNano</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt2</span> <span class="operator">=</span> ldt.withYear(<span class="number">2029</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt3</span> <span class="operator">=</span> ldt.withMinute(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、加多少:</span></span><br><span class="line">        <span class="comment">// plusYears  plusMonths plusDays plusWeeks plusHours plusMinutes plusSeconds plusNanos</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt4</span> <span class="operator">=</span> ldt.plusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt5</span> <span class="operator">=</span> ldt.plusMinutes(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、减多少：</span></span><br><span class="line">        <span class="comment">// minusDays minusYears minusMonths minusWeeks minusHours minusMinutes minusSeconds minusNanos</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt6</span> <span class="operator">=</span> ldt.minusYears(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt7</span> <span class="operator">=</span> ldt.minusMinutes(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、获取指定日期和时间的LocalDateTime对象：</span></span><br><span class="line">        <span class="comment">// public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour,</span></span><br><span class="line">        <span class="comment">//                                  int minute, int second, int nanoOfSecond)</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt8</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2029</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1222</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt9</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2029</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">1222</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、 判断2个日期、时间对象，是否相等，在前还是在后： equals、isBefore、isAfter</span></span><br><span class="line">        System.out.println(ldt9.equals(ldt8));</span><br><span class="line">        System.out.println(ldt9.isAfter(ldt));</span><br><span class="line">        System.out.println(ldt9.isBefore(ldt));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7、可以把LocalDateTime转换成LocalDate和LocalTime</span></span><br><span class="line">        <span class="comment">// public LocalDate toLocalDate()</span></span><br><span class="line">        <span class="comment">// public LocalTime toLocalTime()</span></span><br><span class="line">        <span class="comment">// public static LocalDateTime of(LocalDate date, LocalTime time)</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> ldt.toLocalDate();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">lt</span> <span class="operator">=</span> ldt.toLocalTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">ldt10</span> <span class="operator">=</span> LocalDateTime.of(ld, lt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ZoneId时区"><a href="#ZoneId时区" class="headerlink" title="ZoneId时区"></a>ZoneId时区</h4><h5 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示时区对象;</span><br></pre></td></tr></table></figure>

<h5 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">利用静态方法 of(字符串时区); 获取指定时区对象</span><br><span class="line">利用静态方法 systemDefault();获取当前系统默认时区对象</span><br><span class="line">利用静态方法 getAvailableZoneIds();获取当前系统支持的所有时区对象</span><br></pre></td></tr></table></figure>

<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把时区对象,当成 ZoneDateTime的参数,获取一个带时区的日期对象;</span><br></pre></td></tr></table></figure>

<h5 id="代码案例-10"><a href="#代码案例-10" class="headerlink" title="代码案例"></a>代码案例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.ZonedDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyZoneDate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 获取系统默认的时区对象</span></span><br><span class="line">        System.out.println(ZoneId.systemDefault());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2, 查询所有支持的时区</span></span><br><span class="line">        System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 根据名称获取时区对象</span></span><br><span class="line">        <span class="type">ZoneId</span> <span class="variable">of</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">        System.out.println(of);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4, 获取带时区的日期对象</span></span><br><span class="line">        System.out.println(ZonedDateTime.now());</span><br><span class="line">        System.out.println(ZonedDateTime.now(of));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5，获取，修改，推移时间信息 参考LocalDateTime</span></span><br><span class="line">        System.out.println(ZonedDateTime.now(of).getDayOfMonth());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PART2-Instant"><a href="#PART2-Instant" class="headerlink" title="PART2(Instant)"></a>PART2(Instant)</h3><blockquote>
<p>通过获取Instant的对象可以拿到此刻的时间，该时间由两部分组成：从1970-01-01 00:00:00 开始走到此刻的总秒数+不够1秒的纳秒数。</p>
</blockquote>
<h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于表示时间戳的日期对象,可以精确到纳秒;</span><br></pre></td></tr></table></figure>

<h4 id="获取方法-1"><a href="#获取方法-1" class="headerlink" title="获取方法"></a>获取方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用静态方法 now(); </span><br></pre></td></tr></table></figure>

<h4 id="常用方法-11"><a href="#常用方法-11" class="headerlink" title="常用方法"></a>常用方法</h4><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240127180026656.png" alt="image-20240127180026656"></p>
<h4 id="代码案例-11"><a href="#代码案例-11" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    时间戳对象：可以精确到纳秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 利用静态方法获取对象</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">// 2, 获取总描述</span></span><br><span class="line">        System.out.println(now.getEpochSecond());</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 时间推移</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> now.plusSeconds(-<span class="number">30</span>);</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PART3-DateTimeFormatter"><a href="#PART3-DateTimeFormatter" class="headerlink" title="PART3(DateTimeFormatter)"></a>PART3(DateTimeFormatter)</h3><h4 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是jdk8提供的日期格式化的工具类,可以当成日期格式化和解析日期时候的参数使用;</span><br></pre></td></tr></table></figure>

<h4 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态方法: ofPattern(<span class="string">&quot;模式字符串&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="解析和格式化的方法"><a href="#解析和格式化的方法" class="headerlink" title="解析和格式化的方法"></a>解析和格式化的方法</h4><ol>
<li>解析,使用 日期类(LocalDateTime)中的静态方法 parse,传递要解析的字符串和格式化工具对象;</li>
<li>格式化,使用 日期对象 format(格式化工具对象);</li>
</ol>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240127180726137.png" alt="image-20240127180726137"></p>
<h4 id="代码案例-12"><a href="#代码案例-12" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    思想转变：以日期类或日期对象为主导地位，以工具对象为辅助地位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDateTimeFormatter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 获取一个工具对象</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">sf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 获取当前时间对象</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 3, 格式化</span></span><br><span class="line">        System.out.println(now.format(sf));</span><br><span class="line">        <span class="comment">// 4, 解析</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dt</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2021-01-01 11:11:11&quot;</span>, sf);</span><br><span class="line">        System.out.println(dt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PART4-Period-amp-Duration"><a href="#PART4-Period-amp-Duration" class="headerlink" title="PART4(Period&amp;Duration)"></a>PART4(Period&amp;Duration)</h3><h4 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把一个时间段看成了对象,让程序员可以面向这个时间段操作;</span><br></pre></td></tr></table></figure>

<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>Period: 粗粒度间隔对象</p>
<p>Duration: 细粒度间隔对象</p>
<h4 id="获取方式-1"><a href="#获取方式-1" class="headerlink" title="获取方式"></a>获取方式</h4><p>利用静态方法  between(两个时间对象)</p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>Period能操作只能操作LocalDate;</p>
<p>Duration只能操作带毫秒的时间对象;(除了LocalDate之外的时间对象)</p>
<h4 id="常用方法-12"><a href="#常用方法-12" class="headerlink" title="常用方法"></a>常用方法</h4><ol>
<li>getXxx(); 获取信息或 toXxx()获取信息</li>
<li>Period</li>
</ol>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240127180813814.png" alt="image-20240127180813814"></p>
<ol start="3">
<li>Duration</li>
</ol>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240127180851302.png" alt="image-20240127180851302"></p>
<h4 id="Period代码案例"><a href="#Period代码案例" class="headerlink" title="Period代码案例"></a>Period代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeriodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 获取两个时间对象</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">of</span> <span class="operator">=</span> LocalDate.of(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 2, 利用静态对象获取时间间隔</span></span><br><span class="line">        <span class="type">Period</span> <span class="variable">between</span> <span class="operator">=</span> Period.between(of, now);</span><br><span class="line">        <span class="comment">// 3, 面向间隔时间对象，获取信息</span></span><br><span class="line">        System.out.println(between.getYears());</span><br><span class="line">        System.out.println(between.getMonths());</span><br><span class="line">        System.out.println(between.getDays());</span><br><span class="line">        System.out.println(between.toTotalMonths());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Duration代码案例"><a href="#Duration代码案例" class="headerlink" title="Duration代码案例"></a>Duration代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    概述：把一个时间段看成对象，让程序员可以面向这个时间段操作</span></span><br><span class="line"><span class="comment">        Period：粗粒度间隔对象</span></span><br><span class="line"><span class="comment">        Duration：细粒度间隔对象</span></span><br><span class="line"><span class="comment">    Tips:</span></span><br><span class="line"><span class="comment">        Period 能且只能操作LocalDate</span></span><br><span class="line"><span class="comment">        Duration 只能操作带毫秒的时间对象，除了LocalDate之外的时间对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DurationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 获取两个时间对象</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">of</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2024</span>, <span class="number">1</span>, <span class="number">25</span>, <span class="number">01</span>, <span class="number">02</span>, <span class="number">03</span>);</span><br><span class="line">        <span class="comment">// 2, 利用静态方法获取间隔对象</span></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">between</span> <span class="operator">=</span> Duration.between(of, now);</span><br><span class="line">        <span class="comment">// 3, 获取间隔时间</span></span><br><span class="line">        System.out.println(between.toDays());</span><br><span class="line">        System.out.println(between.toHours());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><blockquote>
<p>什么是Lambda表达式：用于简化匿名内部类代码的书写。</p>
</blockquote>
<h2 id="Lambda表达式基本使用"><a href="#Lambda表达式基本使用" class="headerlink" title="Lambda表达式基本使用"></a>Lambda表达式基本使用</h2><blockquote>
<p>Lamdba是有特有的格式的，按照下面的格式来编写Lamdba。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(被重写方法的形参列表) -&gt; &#123;</span><br><span class="line"> 被重写方法的方法体代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要给说明一下的是，在使用Lambda表达式之前，必须先有一个接口，而且接口中只能有一个<code>抽象方法</code>。<strong>（注意：不能是抽象类，只能是接口）</strong>,使用Lambda来实现该接口，就形成了Lambda表达式。</p>
<p>而在使用Lambda的时候的参数则参考接口中的抽象方法需不需要<code>参数及返回值</code></p>
<p>像这样的接口，我们称之为函数式接口(FunctionInterface)，只有基于函数式接口的匿名内部类才能被Lambda表达式简化。</p>
<p>像这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span>&#123;</span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="代码案例-13"><a href="#代码案例-13" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swimming</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 想要调用go方法必须传递一个Swimming类型的对象</span></span><br><span class="line">        go(<span class="keyword">new</span> <span class="title class_">Swimming</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类方法执行了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 使用Lambda表达式简化上面的匿名内部类(由于接口不需要参数，所以不用传递</span></span><br><span class="line">        go(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Lambda表达式执行了&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">(Swimming s)</span>&#123;</span><br><span class="line">        s.swim();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Lambda简化数组排序"><a href="#使用Lambda简化数组排序" class="headerlink" title="使用Lambda简化数组排序"></a>使用Lambda简化数组排序</h2><h3 id="基本类型数组"><a href="#基本类型数组" class="headerlink" title="基本类型数组"></a>基本类型数组</h3><blockquote>
<p>由于接口Comparable只能传递泛型，所以基本类型不能作为参数传递进去，这里基本类型只能对其长度进行规则排序。</p>
</blockquote>
<h4 id="代码案例-14"><a href="#代码案例-14" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;ccc&quot;</span>, <span class="string">&quot;dddd&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 自己创建一个规则对象</span></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.length() - o2.length();  <span class="comment">// 前减后升序， 后减前降序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;可以使用Lambda表达式简化对数组的排序规则&quot;</span>);</span><br><span class="line">        Arrays.sort(arr, (a, b) -&gt; b.length() - a.length());</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类型数组"><a href="#泛型类型数组" class="headerlink" title="泛型类型数组"></a>泛型类型数组</h3><h4 id="代码案例-15"><a href="#代码案例-15" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用Lambda简化对数组的排序规则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaStringSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果想要使用Comparator进行排序，不能使用基本类型的数组，因为Comparator的参数是泛型</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Lambda对其进行简化&quot;</span>);</span><br><span class="line">        Arrays.sort(arr, (a, b) -&gt; b - a);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda表达式省略规则-※"><a href="#Lambda表达式省略规则-※" class="headerlink" title="Lambda表达式省略规则(※)"></a>Lambda表达式省略规则(※)</h2><blockquote>
<p>Java觉得代码还不够简单，于是还提供了Lamdba表达式的几种简化写法。具体的简化规则如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PROPERTIES</span><br><span class="line"><span class="number">1.</span>Lambda的标准格式</span><br><span class="line">	(参数类型<span class="number">1</span> 参数名<span class="number">1</span>, 参数类型<span class="number">2</span> 参数名<span class="number">2</span>)-&gt;&#123;</span><br><span class="line">		...方法体的代码...</span><br><span class="line">		<span class="keyword">return</span> 返回值;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>在标准格式的基础上()中的参数类型可以直接省略</span><br><span class="line">	(参数名<span class="number">1</span>, 参数名<span class="number">2</span>)-&gt;&#123;</span><br><span class="line">		...方法体的代码...</span><br><span class="line">		<span class="keyword">return</span> 返回值;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="number">3.</span>如果&#123;&#125;总的语句只有一条语句，则&#123;&#125;可以省略、<span class="keyword">return</span>关键字、以及最后的“;”都可以省略</span><br><span class="line">	(参数名<span class="number">1</span>, 参数名<span class="number">2</span>)-&gt; 结果</span><br><span class="line">	</span><br><span class="line"><span class="number">4.</span>如果()里面只有一个参数，则()可以省略</span><br><span class="line">	(参数名)-&gt;结果</span><br></pre></td></tr></table></figure>

<h3 id="代码案例-16"><a href="#代码案例-16" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">JAVA</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 目标：使用Lambda简化函数式接口。</span></span><br><span class="line">        <span class="type">double</span>[] prices = &#123;<span class="number">99.8</span>, <span class="number">128</span>, <span class="number">100</span>&#125;;</span><br><span class="line">		<span class="comment">//1.对数组中的每一个元素*0.8: 匿名内部类写法</span></span><br><span class="line">        Arrays.setAll(prices, <span class="keyword">new</span> <span class="title class_">IntToDoubleFunction</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">applyAsDouble</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">                <span class="comment">// value = 0  1  2</span></span><br><span class="line">                <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//2.需求：对数组中的每一个元素*0.8,使用Lambda表达式标准写法</span></span><br><span class="line">        Arrays.setAll(prices, (<span class="type">int</span> value) -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//3.使用Lambda表达式简化格式1——省略参数类型</span></span><br><span class="line">        Arrays.setAll(prices, (value) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">		<span class="comment">//4.使用Lambda表达式简化格式2——省略()</span></span><br><span class="line">        Arrays.setAll(prices, value -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> prices[value] * <span class="number">0.8</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//5.使用Lambda表达式简化格式3——省略&#123;&#125;</span></span><br><span class="line">        Arrays.setAll(prices, value -&gt; prices[value] * <span class="number">0.8</span> );</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(prices));</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Student[] students = new Student[4];</span></span><br><span class="line"><span class="string">        students[0] = new Student(&quot;</span>蜘蛛精<span class="string">&quot;, 169.5, 23);</span></span><br><span class="line"><span class="string">        students[1] = new Student(&quot;</span>紫霞<span class="string">&quot;, 163.8, 26);</span></span><br><span class="line"><span class="string">        students[2] = new Student(&quot;</span>紫霞<span class="string">&quot;, 163.8, 26);</span></span><br><span class="line"><span class="string">        students[3] = new Student(&quot;</span>至尊宝<span class="string">&quot;, 167.5, 24);</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">        //1.使用匿名内部类</span></span><br><span class="line"><span class="string">        Arrays.sort(students, new Comparator&lt;Student&gt;() &#123;</span></span><br><span class="line"><span class="string">            @Override</span></span><br><span class="line"><span class="string">            public int compare(Student o1, Student o2) &#123;</span></span><br><span class="line"><span class="string">                return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">		//2.使用Lambda表达式表达式——标准格式</span></span><br><span class="line"><span class="string">        Arrays.sort(students, (Student o1, Student o2) -&gt; &#123;</span></span><br><span class="line"><span class="string">                return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">		//3.使用Lambda表达式表达式——省略参数类型</span></span><br><span class="line"><span class="string">        Arrays.sort(students, ( o1,  o2) -&gt; &#123;</span></span><br><span class="line"><span class="string">            return Double.compare(o1.getHeight(), o2.getHeight()); // 升序</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">		//4.使用Lambda表达式表达式——省略&#123;&#125;</span></span><br><span class="line"><span class="string">        Arrays.sort(students, ( o1,  o2) -&gt; Double.compare(o1.getHeight(), o2.getHeight()));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        System.out.println(Arrays.toString(students));</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="集合Collection"><a href="#集合Collection" class="headerlink" title="集合Collection"></a>集合Collection</h1><h2 id="单列集合派系-List-amp-Set"><a href="#单列集合派系-List-amp-Set" class="headerlink" title="单列集合派系(List&amp;Set)"></a>单列集合派系(List&amp;Set)</h2><blockquote>
<p>单列集合是单个的元素，类似于Python中的列表。</p>
<p>容器中的数据都是相互独立的,互不干涉;</p>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240214173151676.png" alt="image-20240214173151676"></p>
<h3 id="Collection集合常用方法"><a href="#Collection集合常用方法" class="headerlink" title="Collection集合常用方法"></a>Collection集合常用方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240214205846050.png" alt="image-20240214205846050"></p>
<h4 id="代码案例-演示常用方法"><a href="#代码案例-演示常用方法" class="headerlink" title="代码案例(演示常用方法)"></a>代码案例(演示常用方法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        Collection&lt;String&gt; c2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        c2.addAll(c);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2, 判断集合中是否包含某个指定的元素， contains 方法判断的时候，依赖对象的equals方法</span></span><br><span class="line">        System.out.println(c2.contains(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;dd&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于多态的限制，不能使用子类特有的方法，如果通过索引操作，只能将集合转成数组然后再操作</span></span><br><span class="line">        <span class="comment">// c.get(0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提前创建对应长度的数组， 用于保存集合中的元素</span></span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[c.size()];</span><br><span class="line">        c.toArray(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h3><blockquote>
<p>List 主要分为ArrayList和LinkedList两种类型的列表。</p>
<p>记住：list集合的特点是：带索引→元素有序，元素可重复。</p>
<h4 id="ArrayList集合特点"><a href="#ArrayList集合特点" class="headerlink" title="ArrayList集合特点"></a>ArrayList集合特点</h4><p>是数组结构,<strong>增删慢,查询快</strong>;适合经常查询,很少增删的场景;</p>
<h4 id="LinkedList集合的特点"><a href="#LinkedList集合的特点" class="headerlink" title="LinkedList集合的特点"></a>LinkedList集合的特点</h4><p>是双向链表结构,<strong>增删快,查询慢</strong>;适合经常增删或经常操作首尾,很少查询的场景;</p>
</blockquote>
<h4 id="ArrayList代码案例-多态"><a href="#ArrayList代码案例-多态" class="headerlink" title="ArrayList代码案例(多态)"></a>ArrayList代码案例(多态)</h4><p>上面Collection代码案例就是。</p>
<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><blockquote>
<p>Set 集合最大的特点就是：不带索引 →元素无序，元素不可重复。</p>
</blockquote>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><blockquote>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>同一个对象,多次调用hashCode方法一定可以得到一个相同的值;</p>
</li>
<li><p>如果两个对象比较的结果是true,那么哈希值一定相同;</p>
</li>
<li><p>如果两个对象比较的结果是false,那么哈希值可能相同也可能不同;</p>
<ul>
<li>比如说没有重写hashcode和equals方法的时候</li>
</ul>
</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>如果使用Hash结构的集合,去除重复元素的依据有两个:</p>
<ol>
<li>依赖对象的哈希值;(决定对象在哈希表中存储的位置)</li>
<li>依赖对象的equals方法;(确保安全)</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 学生实体类 JavaBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (age != student.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">        result = <span class="number">31</span> * result + age;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashSet测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合</span></span><br><span class="line">        HashSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2, 常用方法 参考Collection</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        set.add(s1);</span><br><span class="line">        set.add(s2);</span><br><span class="line">        set.add(s3);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        <span class="comment">// 如果没有在JavaBean类中重写equals和hashcode方法，则三个属性都相同的对象的hashcode就不同</span></span><br><span class="line">        System.out.println(s1.hashCode());</span><br><span class="line">        System.out.println(s2.hashCode());</span><br><span class="line">        System.out.println(s3.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h5><blockquote>
<ul>
<li><p>如果注释掉JavaBean学生实体类中的equals方法，则会将三个相同的对象存进HashSet集合中，但是三者的Hash值相同</p>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240221215042647.png" alt="image-20240221215042647"></p>
</li>
<li><p>如果注释掉Hashcode方法，则equals都不会执行</p>
<ul>
<li>因为：第一个对象来了不比较</li>
<li>第二个对象来了和第一个对象比较，发现Hash值不同，则存进集合</li>
<li>第三个对象来了比较发现Hash值也不同与前两个，所以也存进集合</li>
</ul>
</li>
</ul>
<p>总结：<code>HashSet添加对象的时候先调用的是Hashcode方法</code>，如果没有重写Hashcode方法则三个属性相同的对象的hash值也不相同</p>
</blockquote>
<h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><blockquote>
<p>是set系列的可以对元素自动排序的集合容器;(需要我们自己指定排序规则)</p>
<p><code>特点</code></p>
<ol>
<li>可以排序</li>
<li>不能保证添加元素和获取元素顺序一致</li>
<li>无索引</li>
<li>不能添加重复的元素;(判定元素是否重复不依赖对象的hashcode和equals方法,仅仅依赖排序规则是否返回了0)</li>
</ol>
<p><code>构造方法</code></p>
<ol>
<li>空参数的构造方法</li>
<li>带比较器参数的构造方法;</li>
</ol>
<p><code>常用方法</code></p>
<p>(参考Collection即可)</p>
</blockquote>
<blockquote>
<p>通过第三个代码案例：</p>
<ul>
<li>TreeSet判断元素重复的依据是看重写的排序Lambda方法是否返回了0<ul>
<li>返回0表示重复</li>
<li>不为0表示不重复</li>
<li>如果在排序规则中直接写return 0，则TreeSet集合只会取第一个元素。</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单案例，如果不定义TreeSet的排序规则，则默认是升序排序，且元素不能重复</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetSimple</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 存参数</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        set.add(<span class="number">22</span>);</span><br><span class="line">        set.add(<span class="number">22</span>);</span><br><span class="line">        set.add(<span class="number">11</span>);</span><br><span class="line">        set.add(<span class="number">88</span>);</span><br><span class="line">        set.add(<span class="number">22</span>);</span><br><span class="line">        set.add(<span class="number">99</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定倒序排序规则</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetSimple</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 存参数</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a, b) -&gt; b -a);</span><br><span class="line">        set.add(<span class="number">22</span>);</span><br><span class="line">        set.add(<span class="number">22</span>);</span><br><span class="line">        set.add(<span class="number">11</span>);</span><br><span class="line">        set.add(<span class="number">88</span>);</span><br><span class="line">        set.add(<span class="number">22</span>);</span><br><span class="line">        set.add(<span class="number">99</span>);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用TreeSet保存学生对象，按照学生的年龄排序，年龄相同，按照姓名升序排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTreeset</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合 由于Student类没有实现接口，必须指定排序规则</span></span><br><span class="line">        TreeSet&lt;Student&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((stu1, stu2)-&gt;&#123;</span><br><span class="line">            <span class="comment">// 按照年龄降序排列，去重复的依据就是依赖这个方法是否返回了0， 如果返回0，则认为是重复的！</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stu2.getAge() - stu1.getAge();</span><br><span class="line">            <span class="comment">// 判断res是不是0，如果是0，则说明stu1和stu2年龄一样，继续按照姓名排序</span></span><br><span class="line">            <span class="keyword">return</span> res!=<span class="number">0</span>?res:stu1.getName().compareTo(stu2.getName());</span><br><span class="line">            <span class="comment">// 上面一句为什么不用&#x27;-&#x27;?因为String类型不能用-，看Java文档中String类实现了comparable接口了，所以必定重写了compareTo方法，comparTo最终返回Int值(Comparable接口规定的)</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;ZZz&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xyz&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xyz&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        set.add(s1);</span><br><span class="line">        set.add(s2);</span><br><span class="line">        set.add(s3);</span><br><span class="line">        set.add(s4);</span><br><span class="line">        set.add(s5);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单列集合总结"><a href="#单列集合总结" class="headerlink" title="单列集合总结"></a>单列集合总结</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240222104840155.png" alt="image-20240222104840155"></p>
<h3 id="单列结合综合案例-斗地主"><a href="#单列结合综合案例-斗地主" class="headerlink" title="单列结合综合案例(斗地主)"></a>单列结合综合案例(斗地主)</h3><blockquote>
<p>一个比较综合的案例吧，但只是关于单列集合的，主要知识点有：</p>
<ul>
<li><code>ArrayList作为原始的扑克排面</code>，里面存放的是牌对象，牌对象的属性包含牌面和编号(注意这个编号是不变的且不能重复的，是作为牌的一个唯一性标识，类似于数据库中的主键)</li>
<li><code>使用Collections工具类对集合中的元素打散</code>。</li>
<li>对三名玩家进行发牌，以及留三张底牌，最后打印这<code>四个TreeSet的所有牌面</code>。</li>
</ul>
</blockquote>
<h4 id="代码案例-17"><a href="#代码案例-17" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实体类 pai(属性：牌面 编号)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pai</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String mian;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mian;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> zhi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mian;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMian</span><span class="params">(String mian)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mian = mian;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getZhi</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> zhi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZhi</span><span class="params">(<span class="type">int</span> zhi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.zhi = zhi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pai</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pai</span><span class="params">(String mian, <span class="type">int</span> zhi)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mian = mian;</span><br><span class="line">        <span class="built_in">this</span>.zhi = zhi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 斗地主测试类</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需求分析</span></span><br><span class="line"><span class="comment">    1: 自定义一个牌类,里面包含两个属性,一个用于记录牌面(由花色和点数组成),另一个成员变量用于表示这张牌排序的大小数字;</span></span><br><span class="line"><span class="comment">    2: 准备一个lists系列的集合,用于保存54个牌对象;(组装牌)</span></span><br><span class="line"><span class="comment">    3: 随机打乱顺序;(洗牌)</span></span><br><span class="line"><span class="comment">    4: 准备3个玩家和1个底牌容器,把上面组装的54个对象分发到3个玩家和1个底牌容器中;(发牌)</span></span><br><span class="line"><span class="comment">    5: 对3个玩家和1个底牌容器的牌对象进行排序并打印查询结果</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DDZ</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1， 准备一个list系列的集合，用于保存54个牌对象</span></span><br><span class="line">        List&lt;Pai&gt; poke = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2, 准备花色和点数集合</span></span><br><span class="line">        List&lt;String&gt; huase = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(huase, <span class="string">&quot;♠&quot;</span>,<span class="string">&quot;♥&quot;</span>,<span class="string">&quot;♣&quot;</span>,<span class="string">&quot;♦&quot;</span>);</span><br><span class="line">        List&lt;String&gt; dians = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(dians,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;K&quot;</span>,<span class="string">&quot;Q&quot;</span>,<span class="string">&quot;J&quot;</span>,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;9&quot;</span>,<span class="string">&quot;8&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;6&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;4&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 拼装54个排面对象</span></span><br><span class="line">        <span class="comment">// 先把大小王存进集合中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">zhi</span> <span class="operator">=</span> <span class="number">54</span>;</span><br><span class="line">        <span class="type">Pai</span> <span class="variable">dawagn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pai</span>(<span class="string">&quot;大王&quot;</span>, zhi--);</span><br><span class="line">        <span class="type">Pai</span> <span class="variable">xiaowang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pai</span>(<span class="string">&quot;小王&quot;</span>, zhi--);</span><br><span class="line">        poke.add(dawagn);</span><br><span class="line">        poke.add(xiaowang);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String dian : dians) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : huase) &#123;</span><br><span class="line">            poke.add(<span class="keyword">new</span> <span class="title class_">Pai</span>(s+dian, zhi--));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(poke);</span></span><br><span class="line">        <span class="comment">// 4，洗牌，将组装好的牌进行随机打散</span></span><br><span class="line">        Collections.shuffle(poke);</span><br><span class="line">        <span class="comment">// System.out.println(poke);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5, 准备三个玩家，三个容器，将扑克发到每个玩家手中</span></span><br><span class="line">        Comparator&lt;Pai&gt; rule = (a, b) -&gt; b.getZhi() - a.getZhi() ;  <span class="comment">// 前 - 后 升序。后-前降序</span></span><br><span class="line">        TreeSet&lt;Pai&gt; wanjia1 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(rule);</span><br><span class="line">        TreeSet&lt;Pai&gt; wanjia2 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(rule);</span><br><span class="line">        TreeSet&lt;Pai&gt; wanjia3 = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(rule);</span><br><span class="line">        TreeSet&lt;Pai&gt; dipai = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(rule);</span><br><span class="line">        <span class="comment">// 当大集合的索引大于等于51的时候，就是最后三张牌，直接给底牌即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poke.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 根据索引获取牌对象</span></span><br><span class="line">            <span class="type">Pai</span> <span class="variable">pai</span> <span class="operator">=</span> poke.get(i);</span><br><span class="line">            <span class="comment">// 判断集合的索引大于等于51的时候，就是最后三张牌，直接给底牌即可</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">51</span>)&#123;</span><br><span class="line">                dipai.add(pai);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                    wanjia1.add(pai);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i % <span class="number">3</span> == <span class="number">2</span>)&#123;</span><br><span class="line">                    wanjia2.add(pai);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    wanjia3.add(pai);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6, 看牌</span></span><br><span class="line">        System.out.println(wanjia1);</span><br><span class="line">        System.out.println(wanjia2);</span><br><span class="line">        System.out.println(wanjia3);</span><br><span class="line">        System.out.println(dipai);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="双列集合派系-Map"><a href="#双列集合派系-Map" class="headerlink" title="双列集合派系(Map)"></a>双列集合派系(Map)</h2><blockquote>
<p><code>Map集合是什么：</code></p>
<ul>
<li>是双列集合顶层的接口,带有两个泛型,里面存储的都是键值对数据;(键和值一一对应,键不能重复,值可以重复)</li>
<li>其中双列集合可以理解为Python中的字典，是kv键值对形式。</li>
</ul>
<p><code>特点</code></p>
<ol>
<li>存储的都是键值对数据;</li>
<li>键不能重复,值可以重复;</li>
</ol>
</blockquote>
<h3 id="Map集合体系"><a href="#Map集合体系" class="headerlink" title="Map集合体系"></a>Map集合体系</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240224214519821.png" alt="image-20240224214519821"></p>
<p>用的最多的：</p>
<ul>
<li><code>HashMap: 无序，不重复，无索引</code></li>
</ul>
<h3 id="Map集合常用方法"><a href="#Map集合常用方法" class="headerlink" title="Map集合常用方法"></a>Map集合常用方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240224215246821.png" alt="image-20240224215246821"></p>
<p>用的最多的：</p>
<ul>
<li><code>添加元素：put()</code></li>
<li><code>根据键来获取对应的值：get(key)</code></li>
<li><code>获取全部键的集合：keySet()</code></li>
</ul>
<h4 id="代码案例-18"><a href="#代码案例-18" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建Map集合对象</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2, 存数据 增加和修改都可以通过put来实现</span></span><br><span class="line">        System.out.println(map.put(<span class="number">120</span>, <span class="string">&quot;牛肉拉面&quot;</span>));</span><br><span class="line">        map.put(<span class="number">110</span>, <span class="string">&quot;兰州牛肉拉面&quot;</span>);</span><br><span class="line">        map.put(<span class="number">130</span>, <span class="string">&quot;西北拉面&quot;</span>);</span><br><span class="line">        System.out.println(map.put(<span class="number">120</span>, <span class="string">&quot;河南烩面&quot;</span>));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// 根据key获取对应的value</span></span><br><span class="line">        System.out.println(map.get(<span class="number">110</span>));</span><br><span class="line">        System.out.println(map.getOrDefault(<span class="number">111</span>, <span class="string">&quot;自定义的默认值&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">        <span class="comment">// keySet 获取所有的键值, 组合成单列集合</span></span><br><span class="line">        Set&lt;Integer&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : set) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;===&gt;&quot;</span> + map.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双列集合之-Entry"><a href="#双列集合之-Entry" class="headerlink" title="双列集合之-Entry"></a>双列集合之-Entry</h3><blockquote>
<p>可以将Map集合中的每一个键和值看成一个整体，整体类型是<code>Map.Entry 类型</code></p>
<p>因为将键和值看成一个整体之后，Map就变成了单列集合，因此<code>可以使用增强for进行遍历。</code></p>
</blockquote>
<h4 id="具体操作案例"><a href="#具体操作案例" class="headerlink" title="具体操作案例"></a>具体操作案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapEntry</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建map集合对象</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2, 存数据 增加和修改都可以使用put方法</span></span><br><span class="line">        map.put(<span class="number">120</span>, <span class="string">&quot;牛肉拉面&quot;</span>);</span><br><span class="line">        map.put(<span class="number">110</span>, <span class="string">&quot;兰州牛肉拉面&quot;</span>);</span><br><span class="line">        map.put(<span class="number">130</span>, <span class="string">&quot;西北拉面&quot;</span>);</span><br><span class="line">        map.put(<span class="number">120</span>, <span class="string">&quot;河南烩面&quot;</span>);</span><br><span class="line">        <span class="comment">// 3, 将每一个键和值看成一个整体 整体类型是Map.Entry 类型</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, String&gt;&gt; set = map.entrySet();</span><br><span class="line">        <span class="comment">// 4, 使用增强for遍历set，可以得到每一个 Entry 类型对象</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : set) &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key +<span class="string">&quot;===&gt;&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map集合的三种遍历方式"><a href="#Map集合的三种遍历方式" class="headerlink" title="Map集合的三种遍历方式"></a>Map集合的三种遍历方式</h3><blockquote>
<p>第一种遍历方式：</p>
<ul>
<li>通过获取集合中所有键的集合，然后根据键来获取集合中所有的值。</li>
</ul>
<p>第二种遍历方式：</p>
<ul>
<li>通过将键值对看成一个Entry整体，通过增强for的方式遍历集合</li>
</ul>
<p>第三种遍历方式：</p>
<ul>
<li><code>使用forEach结合Lambda表达式进行遍历（方便快捷）</code></li>
</ul>
<p>前面两种方式基本都没有什么难度，下面直接使用第三种最快接的遍历方式，上代码！</p>
</blockquote>
<h4 id="代码案例-19"><a href="#代码案例-19" class="headerlink" title="代码案例"></a>代码案例</h4><blockquote>
<p>这里最 需要关注的就是集合的第三种遍历方式，通过<code>ForEach+Lambda</code>.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    求数组中每个字符串出现的次数，及出现次数最多的字符串和对应的次数(模拟投票案例)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapVoteDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 准备原始数据</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;D&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;A&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;A&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// 2, 使用Map集合统计投票的结果，使用景点当成Map的key，景点被选的次数当成Map的value</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 3, 遍历数组，从数组中获取每一个元素，从map中按照key取值，如果没有key则取到null这是就将null变为1，否则就+1</span></span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            map.put(s, map.getOrDefault(s, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">/* 上面的和下面的多句话是一个意思</span></span><br><span class="line"><span class="comment">            Integer i = map.get(s);</span></span><br><span class="line"><span class="comment">            if (i == null)&#123;</span></span><br><span class="line"><span class="comment">                map.put(s, 1);</span></span><br><span class="line"><span class="comment">            &#125;else &#123;</span></span><br><span class="line"><span class="comment">                map.put(s, i+1);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// 获取所有的value组成的单列集合，并获取最大值，再次遍历map集合，如果某个值和最大值相等，则对应的key就是我们要找的数据</span></span><br><span class="line">        Collection&lt;Integer&gt; values = map.values();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(values);</span><br><span class="line">        System.out.println(max);</span><br><span class="line">        <span class="comment">// 再次遍历map结合，如果某个值是和最大值相等，则对应的key就是我们要找的数据</span></span><br><span class="line">        map.forEach((k,v)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (v == max)&#123;</span><br><span class="line">                System.out.println(k + <span class="string">&quot;景点人数是最多的，人数为：&quot;</span>+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景-统计词频"><a href="#应用场景-统计词频" class="headerlink" title="应用场景(统计词频)"></a>应用场景(统计词频)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    键盘输入一串字符串，统计字符串中每个字符出现的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharFrequency</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 键盘输入一个字符串</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一串字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="comment">// 2, 遍历字符串，将字符串中的每一个字符都当成map的key，这个字符出现的次数当成map的value存储起来</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; next.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> next.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><blockquote>
<p>HashMap就是Map接口中的一个实现类，底层是HashTable表结构，会<code>根据键来进行去重</code>，根据键去重的依据是<code>equals和HashCode方法</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student 类这里就不写了，就是带有两个私有属性，name和age，并且重写了toString和HashCode和equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerizeKey</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合</span></span><br><span class="line">        HashMap&lt;Student, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2, 创建3个集合对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三2&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(s1, <span class="string">&quot;河南&quot;</span>);</span><br><span class="line">        map.put(s2, <span class="string">&quot;河北&quot;</span>);</span><br><span class="line">        map.put(s3, <span class="string">&quot;山东&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// 结果：&#123;Student&#123;name=&#x27;张三&#x27;, age=18&#125;=山东, Student&#123;name=&#x27;张三2&#x27;, age=19&#125;=河北&#125;</span></span><br><span class="line">        <span class="comment">// 原因：因为HashMap根据键进行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><blockquote>
<p>就是HashMap的一个子类，可以<code>保证数据有序</code>，其他的都和HashMap一样。</p>
<p>其顺序的是现实通过元素添加的顺序来维护的，键的进栈顺序。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean 就不写了，跟上面的一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyLinkedHashMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合</span></span><br><span class="line">        LinkedHashMap&lt;Student, String&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2, 创建3个集合对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三2&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三3&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        </span><br><span class="line">        map.put(s1, <span class="string">&quot;河南&quot;</span>);</span><br><span class="line">        map.put(s2, <span class="string">&quot;河北&quot;</span>);</span><br><span class="line">        map.put(s3, <span class="string">&quot;山东&quot;</span>);</span><br><span class="line"></span><br><span class="line">        map.put(s4, <span class="string">&quot;山洞&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">// s4对象最先添加：&#123;Student&#123;name=&#x27;张三3&#x27;, age=18&#125;=山洞, Student&#123;name=&#x27;张三&#x27;, age=18&#125;=山东, Student&#123;name=&#x27;张三2&#x27;, age=19&#125;=河北&#125;</span></span><br><span class="line">        <span class="comment">// s4对象最后添加：&#123;Student&#123;name=&#x27;张三&#x27;, age=18&#125;=山东, Student&#123;name=&#x27;张三2&#x27;, age=19&#125;=河北, Student&#123;name=&#x27;张三3&#x27;, age=18&#125;=山洞&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><blockquote>
<p>可以对键按自定义规则排序, <code>TreeMap 判断键是否重复的条件是 排序Lambda是否返回了0</code>;</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean 就不写了，跟上面的一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTreeMap</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合</span></span><br><span class="line">        Map&lt;Student, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((stu1, stu2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 根据对象的年龄进行降序排序</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> stu2.getAge() - stu1.getAge();</span><br><span class="line">            <span class="comment">// 如果年龄相同则根据姓名降序排序，TreeMap 判断键是否重复的条件是 排序Lambda是否返回了0</span></span><br><span class="line">            <span class="keyword">return</span> i == <span class="number">0</span> ? stu2.getName().compareTo(stu2.getName()) : i;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 2, 创建3个集合对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三2&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三3&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        map.put(s1, <span class="string">&quot;河南&quot;</span>);</span><br><span class="line">        map.put(s2, <span class="string">&quot;河北&quot;</span>);</span><br><span class="line">        map.put(s3, <span class="string">&quot;山东&quot;</span>);</span><br><span class="line"></span><br><span class="line">        map.put(s4, <span class="string">&quot;山洞&quot;</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="集合嵌套-三种遍历"><a href="#集合嵌套-三种遍历" class="headerlink" title="集合嵌套(三种遍历)"></a><code>集合嵌套</code>(三种遍历)</h3><blockquote>
<p>需求说明：定义一个map集合,使用省的名称当成键,使用省中的各个市的名称当成value;也就是一个省对应多个市</p>
<p>重点在于：<code>使用三种不同的方式遍历嵌套的集合</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionNested</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 定义一个map集合用来保存一个省份(键)对应多个城市(值),这里的城市是不能有重复的所以用HashSet结构</span></span><br><span class="line">        HashMap&lt;String, HashSet&lt;String&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2, 准备各个省份中的市</span></span><br><span class="line">        HashSet&lt;String&gt; hn = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(hn, <span class="string">&quot;周口市&quot;</span>,<span class="string">&quot;洛阳市&quot;</span>,<span class="string">&quot;南阳市&quot;</span>,<span class="string">&quot;信阳市&quot;</span>,<span class="string">&quot;濮阳市&quot;</span>);</span><br><span class="line">        HashSet&lt;String&gt; hb = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(hb, <span class="string">&quot;石家庄&quot;</span>,<span class="string">&quot;张家口&quot;</span>,<span class="string">&quot;唐山市&quot;</span>,<span class="string">&quot;保定市&quot;</span>);</span><br><span class="line"></span><br><span class="line">        map.put(<span class="string">&quot;河南&quot;</span>, hn);</span><br><span class="line">        map.put(<span class="string">&quot;河北&quot;</span>, hb);</span><br><span class="line">        <span class="comment">// 遍历并打印 方式一：keySet方式,就是先获取所有的键，通过键找对应的值</span></span><br><span class="line">        Set&lt;String&gt; set = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String province : set) &#123;</span><br><span class="line">            HashSet&lt;String&gt; citys = map.get(province);</span><br><span class="line">            <span class="keyword">for</span> (String city : citys) &#123;</span><br><span class="line">                System.out.println(province+<span class="string">&quot;下面有：&quot;</span>+city);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;======&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------方式一结束-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历并打印 方式二：entrySet方式 面向Entry对象，获取省和市组成的单列集合</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, HashSet&lt;String&gt;&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, HashSet&lt;String&gt;&gt; entry : entries) &#123;</span><br><span class="line">            <span class="comment">// 面向Entry对象，可以获取省的名称和对应市组成的单列集合</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">province</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            HashSet&lt;String&gt; citys = entry.getValue();</span><br><span class="line">            <span class="keyword">for</span> (String city : citys) &#123;</span><br><span class="line">                System.out.println(province + <span class="string">&quot;下面有：&quot;</span> +city);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------方式二结束-------&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历并打印 方式三：forEach+Lambda方式</span></span><br><span class="line">        map.forEach((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (String s : b) &#123;</span><br><span class="line">                System.out.println(a+<span class="string">&quot;下面有：&quot;</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;=====&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>专门针对集合进行遍历的一个对象;(集合的助手)</p>
<p>如果想使用迭代器遍历集合：</p>
<ul>
<li>首先需要有一个集合对象。</li>
<li>其次面向集合对象通过：集合对象.iterator()的形式获取一个迭代器对象。</li>
<li>最后面向迭代器对象，遍历集合中的所有元素。</li>
</ul>
</blockquote>
<h3 id="获取方式-2"><a href="#获取方式-2" class="headerlink" title="获取方式"></a>获取方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用集合的 iterator()方法即可获取迭代器对象;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-13"><a href="#常用方法-13" class="headerlink" title="常用方法"></a>常用方法</h3><ol>
<li>hasNext(); 判断是否有元素可以获取;</li>
<li>next(); 获取元素;</li>
<li>remove();删除当前遍历到的这个元素;</li>
</ol>
<h3 id="代码案例-20"><a href="#代码案例-20" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    迭代器的基本使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 面向c对象，获取一个迭代器对象</span></span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 面向迭代器对象，获取集合中的每一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器使用注意事项"><a href="#迭代器使用注意事项" class="headerlink" title="迭代器使用注意事项"></a>迭代器使用注意事项</h3><blockquote>
<ul>
<li>在迭代器迭代集合的过程中,不能使用集合的方法改变集合的长度;</li>
<li>在一次遍历过程中,最多只能使用一次  next方法,否则可能会出问题;</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 面向 c对象，获取一个迭代器对象</span></span><br><span class="line">        Iterator&lt;String&gt; it = c.iterator();</span><br><span class="line">        <span class="comment">// 3, 面向迭代器对象，获取集合中的每一个元素</span></span><br><span class="line">        <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> it.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">            <span class="keyword">if</span> (next.equals(<span class="string">&quot;dd&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">// c.remove(&quot;dd&quot;) 不能使用集合的方法删除数据， 可以利用迭代器自身的方法删除数据</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删除集合元素的方法"><a href="#删除集合元素的方法" class="headerlink" title="删除集合元素的方法"></a>删除集合元素的方法</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240222105208628.png" alt="image-20240222105208628"></p>
<h2 id="增强for"><a href="#增强for" class="headerlink" title="增强for"></a>增强for</h2><h3 id="概述-amp-实例演示"><a href="#概述-amp-实例演示" class="headerlink" title="概述&amp;实例演示"></a>概述&amp;实例演示</h3><p>对迭代器和数组遍历方式的语法格式简化。我要是不知道Python中for循环的两种遍历格式，还就真被这个b骗了。</p>
<p>就是一丫的for in in list这种东西，不要认为有多么的高大上，其实Python大家都知道很大一部分简化了Java的代码。</p>
<ul>
<li>作用</li>
</ul>
<p>遍历单列集合或数组;</p>
<ul>
<li>格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 变量名:容器)&#123;</span><br><span class="line">    此时的变量名就是容器中的每一个元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>代码案例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    增强for循环：对迭代器和数组遍历方式的语法格式简化，其作用是遍历单列集合或者数组</span></span><br><span class="line"><span class="comment">        格式：for(元素类型 变量名:容器)&#123;</span></span><br><span class="line"><span class="comment">            此时的变量名就是容器中的每一个元素</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        个人感觉就是在Python中不写for i in range 写 for i in 集合名称 这种。比较简单，要是没学过Python还就真类比不了了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnhanceFor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        <span class="comment">// 2，使用增强for对集合进行遍历，增强for遍历集合的时候，也是利用了迭代器，所以也不能再遍历过程中修改集合的长度（删除、添加元素</span></span><br><span class="line">        <span class="keyword">for</span> (String i:c)&#123;</span><br><span class="line">            <span class="comment">// i 表示的是集合中的每个元素</span></span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合中与Lambda相关的两个方法"><a href="#集合中与Lambda相关的两个方法" class="headerlink" title="集合中与Lambda相关的两个方法"></a>集合中与Lambda相关的两个方法</h2><h3 id="forEach-lambda"><a href="#forEach-lambda" class="headerlink" title="forEach(lambda)"></a>forEach(lambda)</h3><blockquote>
<p>遍历集合;</p>
<ul>
<li>使用方法：使用<code>集合名称.forEach(lambda)</code></li>
</ul>
</blockquote>
<h3 id="removeIf-lambda"><a href="#removeIf-lambda" class="headerlink" title="removeIf(lambda)"></a>removeIf(lambda)</h3><blockquote>
<p>删除所有满足规则的数据;</p>
<ul>
<li>使用方法：同上</li>
</ul>
</blockquote>
<h3 id="代码案例-21"><a href="#代码案例-21" class="headerlink" title="代码案例"></a>代码案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    集合中和Lambda相关的两个方法</span></span><br><span class="line"><span class="comment">        1，ForEach(lambda)：遍历即可</span></span><br><span class="line"><span class="comment">        2，removelf(Lambda)：删除所有满足规则的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionWithLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合对象</span></span><br><span class="line">        Collection&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 删除集合中所有满足规则的数据，在removeIf的方法中，通过Lambda描述规则即可</span></span><br><span class="line">        <span class="comment">// 删除所有的cc</span></span><br><span class="line">        c.removeIf(s -&gt; s.equals(<span class="string">&quot;cc&quot;</span>));</span><br><span class="line">        <span class="comment">// 看看集合中是否少了cc这些元素</span></span><br><span class="line">        System.out.println(c.toString());</span><br><span class="line">        <span class="comment">// 删除所有长度为2的字符串</span></span><br><span class="line">        c.removeIf(s -&gt; s.length() == <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用c对象可以直接调用接口中的默认方法</span></span><br><span class="line">        <span class="comment">// c.forEach(s -&gt; System.out.println(s));  // 正常的Lambda</span></span><br><span class="line">        c.forEach(System.out::println);  <span class="comment">// 成员方法引用</span></span><br><span class="line">        Object[] array = c.toArray();</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合工具类Collections"><a href="#集合工具类Collections" class="headerlink" title="集合工具类Collections"></a>集合工具类Collections</h1><blockquote>
<p>Collections工具类是一个专门操作集合的工具类，通过类名.方法名即可调用集合中的方法。</p>
<p>常见的操作有:</p>
<ul>
<li>批量添加数据:<code>Collections.addAll</code></li>
<li>排序:<code>Collections.sort(集合, 比较器)</code></li>
<li>随机打散:<code>Collections.shuffle</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTools</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建一个集合容器</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2, 批量添加数据</span></span><br><span class="line">        Collections.addAll(list, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// 3. 排序</span></span><br><span class="line">        Collections.sort(list, (a, b)-&gt; a-b);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        <span class="comment">// 4, 随机打乱顺序</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h1><blockquote>
<p>关于可变参数就记住两点就行：语法格式 和 本质。</p>
<p>可变参数就是类似于Python中的*args, **kwargs，其中*args会将函数的参数以元组的形式保存起来，**kwargs会将多余的参数以键值对的方式保存起来。</p>
<p>语法格式为：</p>
<ul>
<li><code>数据类型...参数名(注意必须为3个.)</code></li>
</ul>
<p><code>本质：数组，但是比数组接受更多情况的实际参数。</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlexiblePara</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(getSum(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">        System.out.println(getSum(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>));</span><br><span class="line">        System.out.println(getSum(<span class="number">1</span>));</span><br><span class="line">        System.out.println(getSum());</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(getSum(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>...arr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><blockquote>
<p>正则表达式：编程界通用的一种工具。</p>
<p>这个东西，你只要能看懂各种符号就行，不用很熟，再熟不复习也会淡忘的，何况实际开发中如果真需要并且不会写就只要在网上搜索在线正则表达式就行。</p>
</blockquote>
<h2 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h2><ul>
<li><code>. 任意单个字符</code></li>
<li><code>[] 括号列举的字符</code></li>
<li><code>/d 数字/D 非数字</code></li>
<li><code>/s 空白 /S 非空白</code></li>
<li><code>/w 非特殊字符(数字字母汉字下划线 /W 特殊字符</code></li>
</ul>
<h2 id="匹配多个字符"><a href="#匹配多个字符" class="headerlink" title="匹配多个字符"></a>匹配多个字符</h2><ul>
<li><code>匹配前一个字符0到多次*</code></li>
<li><code>匹配前一个字符1到多次+</code></li>
<li><code>匹配前一个字符0-1次(非贪婪匹配)?</code></li>
<li><code>匹配前一个字符m次 &#123;m&#125;</code></li>
<li><code>匹配前一个字符至少m次 &#123;m,&#125;</code></li>
<li><code>匹配前一个字符m到n次&#123;m,n&#125;</code></li>
</ul>
<h2 id="分组匹配"><a href="#分组匹配" class="headerlink" title="分组匹配"></a>分组匹配</h2><blockquote>
<p>首先了解分组是什么东西!一个括号()中的东西就可以是一个分组.</p>
<p>对于分组的操作, 可以取分组中的|左右的任意字符,也可以对分组其别名,方便后面复用.</p>
</blockquote>
<ul>
<li><code>| 匹配左右任意一个表达式</code></li>
<li><code>(ab) 将括号中字符作为一个分组</code></li>
<li><code>\num 引用分组num匹配到的字符串</code></li>
<li><code>(?P&lt;name&gt;) 分组起别名</code></li>
<li><code>(?P=name) 引用别名为name分组匹配到的字符串</code></li>
</ul>
<h2 id="代码案例-22"><a href="#代码案例-22" class="headerlink" title="代码案例"></a>代码案例</h2><h3 id="验证数据是否正确"><a href="#验证数据是否正确" class="headerlink" title="验证数据是否正确"></a>验证数据是否正确</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    正则表达式的精髓就在于：</span></span><br><span class="line"><span class="comment">        匹配单个字符：. [] \\W这些带\的东西，而且还不能是一个\，并且还是两个\</span></span><br><span class="line"><span class="comment">        匹配多个字符：</span></span><br><span class="line"><span class="comment">        特殊类：^(取反)， &amp;&amp;(取交集)，|(取并集)， \(转移字符)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexApp_verifyData</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 自定义一个字符串数据</span></span><br><span class="line">        <span class="comment">// 匹配邮箱的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">email</span> <span class="operator">=</span> <span class="string">&quot;a-234@qq.com.cn.org&quot;</span>;</span><br><span class="line">        String regEm= <span class="string">&quot;[a-z0-9A-Z]+[-|a-z0-9A-Z._]+@([a-z0-9A-Z]+(-[a-z0-9A-Z]+)?\\.)+[a-z]&#123;2,&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(email.matches(regEm));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匹配电话的</span></span><br><span class="line">        <span class="comment">//String regPh = &quot;(?:(?:+|00)86)?1[3-9]\\d&#123;9&#125;&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regPh</span> <span class="operator">=</span> <span class="string">&quot;0[0-9]&#123;2,3&#125;-[0-9]&#123;7,8&#125;&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> <span class="string">&quot;031-33333383&quot;</span>;</span><br><span class="line">        System.out.println(tel.matches(regPh));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间的</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regTime</span> <span class="operator">=</span> <span class="string">&quot;[1-9]\\d&#123;3&#125;-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])\\s+(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d&quot;</span>;</span><br><span class="line">        <span class="type">String</span>  <span class="variable">time</span> <span class="operator">=</span> <span class="string">&quot;1999-11-11 12:12:12&quot;</span>;</span><br><span class="line">        System.out.println(time.matches(regTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="提取想要的数据"><a href="#提取想要的数据" class="headerlink" title="提取想要的数据"></a>提取想要的数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    需求：从一段文字中提取出想要的信息。(比如如下匹配所有的电话号码-包括但不限于座机，手机等号码，电子邮箱)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegexApp_extractInfo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> <span class="string">&quot; 来xxx教育机构学习Java，电话：1866668888，18699997777 或者联系邮箱：boniu@itcast.cn， 座机电话：01036517895，010-98951256 邮箱：bozai@itcast.cn，   邮箱2：dlei0009@163.com， 热线电话：400-618-9090 ，400-618-4000，4006184000，4006189090&quot;</span>;</span><br><span class="line">        <span class="comment">// \\w是匹配一个非特殊字符，像\\d是匹配数字 \\D 匹配非数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(\\w&#123;1,&#125;@\\w&#123;2,10&#125;(\\.\\w&#123;2,10&#125;)&#123;1,2&#125;)|(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,5&#125;-?\\d&#123;5,15&#125;)|400-?\\d&#123;3,8&#125;-?\\d&#123;3,8&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1,将正则字符串编译成一个正则对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line">        <span class="comment">// 2, 使用编译后的正则对象，匹配数据</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> compile.matcher(data);</span><br><span class="line">        <span class="comment">// 3, 遍历matcher 结果对象， find是判断是否有匹配的结果</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">            <span class="comment">// group 获取匹配的结果</span></span><br><span class="line">            System.out.println(matcher.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h2><blockquote>
<p>主要关心的就是<code>编译时异常</code>和<code>运行时异常</code>。</p>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240220102954164.png" alt="image-20240220102954164"></p>
<h2 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h2><blockquote>
<p>异常处理的方法有两种：</p>
<ul>
<li>throws抛出异常<ul>
<li>将方法内部出现的异常交给调用者处理</li>
<li>语法：<code>方法名 throws Exception1, Exception2.....</code></li>
</ul>
</li>
<li>try catch捕获异常<ul>
<li>直接捕获程序中出现的异常</li>
<li>语法：<code>try &#123;&#125; catch(Exception e) &#123;e.printStackTrace&#125;</code></li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240220221626845.png" alt="image-20240220221626845"></p>
<h3 id="编译阶段的异常"><a href="#编译阶段的异常" class="headerlink" title="编译阶段的异常"></a>编译阶段的异常</h3><blockquote>
<p>大白话：就是在编译阶段出现的异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习编译时期异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompileException</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException&#123;</span><br><span class="line">        <span class="comment">// 1, 创建一个日期格式化工具</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 解析</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">d</span> <span class="operator">=</span> sdf.parse(<span class="string">&quot;2023-02-03 11-11-11&quot;</span>);</span><br><span class="line">            System.out.println(d);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><code>如果上面的没有在main方法后面加throws Exception且没有try catch处理则会编译报红</code></p>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240220222859787.png" alt="image-20240220222859787"></p>
<h3 id="运行阶段的异常"><a href="#运行阶段的异常" class="headerlink" title="运行阶段的异常"></a>运行阶段的异常</h3><blockquote>
<p>顾名思义，如果单单在方法后使用throws 则会把异常踢给main函数的调用者，也就是jvm，跟throws拋不抛异常没多大区别，最终都是jvm来处理。</p>
<p>但是如果使用try catch就是自己来处理异常了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="comment">// 也可以处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> getValue(arr, <span class="number">5</span>);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 提示程序处理问题，面向异常对象e，直接打印信息</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;已经捕获到异常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><blockquote>
<p>指的就是自定义了一个继承了Java已经写好的异常体系中的任意的类。</p>
</blockquote>
<h3 id="运行时异常-非受检异常"><a href="#运行时异常-非受检异常" class="headerlink" title="运行时异常(非受检异常)"></a>运行时异常(非受检异常)</h3><blockquote>
<p>只有运行时才会告诉调用者程序出现了错误。</p>
</blockquote>
<h4 id="代码案例-23"><a href="#代码案例-23" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异常类 继承自 RuntimeException</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception1</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exception1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exception1</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类 在运行时抛出异常</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(getIndex(<span class="literal">null</span>, <span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 抛出一个无法完成任务的异常，因为异常是一个对象，所以要new</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception1</span>(<span class="string">&quot;亲，数组不能为null啊。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到的话就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="编译时异常-受检异常"><a href="#编译时异常-受检异常" class="headerlink" title="编译时异常(受检异常)"></a>编译时异常(受检异常)</h3><blockquote>
<p>若调用者调用了某个方法，会自动检查调用者的传递参数等其他条件，不满足则在编译时就报错。</p>
</blockquote>
<h4 id="代码案例-24"><a href="#代码案例-24" class="headerlink" title="代码案例"></a>代码案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异常类 继承自Exception（只需要alt+insert生成两个构造方法就行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Exception2</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exception2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Exception2</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(getIndex(<span class="literal">null</span>, <span class="number">10</span>));</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception2 e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;如果上面捕获到异常，那么虚拟机就认为main没有发生异常，我就可以执行。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key)</span> <span class="keyword">throws</span> Exception2 &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 抛出一个无法完成任务的异常，因为异常是一个对象，所以要new</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception2</span>(<span class="string">&quot;亲，数组不能为null啊。。。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == key)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有找到的话就返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><blockquote>
<p>流是什么？</p>
<p>是java提供的一套专门操作数组或单列集合的API,允许我们使用lambda对数据按照指定的流程处理,将处理的结果收集起来;</p>
</blockquote>
<h2 id="获取流的四种情况-三种方式"><a href="#获取流的四种情况-三种方式" class="headerlink" title="获取流的四种情况(三种方式)"></a>获取流的四种情况(三种方式)</h2><ul>
<li>零散数据    <code> 可以利用Stream接口中的静态方法  Stream.of(T...);</code></li>
<li>数组数据    <code>可以利用Arrays的静态方法 stream(数组);</code></li>
<li>单列集合   <code>可以利用Collection接口的默认方法 stream();</code></li>
<li>双列集合    <code>需要先转成单列集合,在利用单列集合的方式获取流对象;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习获取流对象的三种方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 将一堆零散数据，封装成流对象</span></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 2, 使用流的终结方法foreach可以遍历流中的每一个数据</span></span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 3, 将数组转换成流对象</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">stream1</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">        stream1.forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 4, 将单列集合转换成流对象</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream2 = list.stream();</span><br><span class="line">        stream2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最好不要使用of 方法传递数组，否则可能会将数组当成一个元素，存入流对象中进行处理</span></span><br><span class="line">        Stream&lt;<span class="type">int</span>[]&gt; arr1 = Stream.of(arr);</span><br><span class="line">        arr1.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流的终结方法"><a href="#流的终结方法" class="headerlink" title="流的终结方法"></a>流的终结方法</h2><blockquote>
<p>任何的流调用完终结方法之后，就不会存在了，也就是流就结束了。</p>
</blockquote>
<p><code>常用的终结方法有：</code></p>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240227215326614.png" alt="image-20240227215326614"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习流对象的终结方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TerminateStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 将一堆零散数据，封装成流对象</span></span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>);</span><br><span class="line">        <span class="comment">// 2, 获取数量 (流一旦调用了终结方法，流的状态就已经结束了，不能再继续调用其他方法)</span></span><br><span class="line">        System.out.println(stream.count());</span><br><span class="line">        <span class="comment">// 3, 再创建一个新的流对象</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;A&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">&quot;B&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        map.put(<span class="string">&quot;C&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        map.put(<span class="string">&quot;D&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 4，将Map中所有的value获取出来组成一个单列集合，再获取单列集合的流对象，利用流的max方法获取最大值</span></span><br><span class="line">        System.out.println(map.values().stream().max((a, b) -&gt; a - b).get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="流的中间方法"><a href="#流的中间方法" class="headerlink" title="流的中间方法"></a>流的中间方法</h2><blockquote>
<p>顾名思义：就是主要对流做一些数据处理的方法，处理完成后流还会存在。</p>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240227215752678.png" alt="image-20240227215752678"></p>
</blockquote>
<p><code>用的最多的中间方法：</code></p>
<ul>
<li>fileter-过滤</li>
<li>map-加工处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习流对象的中间方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MiddleMethodOfStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 使用集合存储一些字符串数据</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, <span class="string">&quot;张翠山&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张翠花&quot;</span>,<span class="string">&quot;张翠翠&quot;</span>,<span class="string">&quot;战三&quot;</span>,<span class="string">&quot;华安&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张伟&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 获取流，直接. 不建议使用变量接收流对象运行的结果(除非是确定到了最终想要的结果了)</span></span><br><span class="line">        <span class="comment">// 找出所有姓张并且姓名长度为3的名字打印出来</span></span><br><span class="line">        list.stream()</span><br><span class="line">                .filter(a -&gt; a.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                .filter(s -&gt;s.length()==<span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 3，对数组中的元素：找出大于等于3的并且排序后只要前3个并打印</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        Arrays.stream(arr)</span><br><span class="line">                .filter(s -&gt; s&gt;=<span class="number">3</span>).sorted().limit(<span class="number">3</span>)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4, 对字符串数组中的数字进行提取，然后去重，降序排列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;123,66,22,88,25,99,1024,55,22,66,123&quot;</span>;</span><br><span class="line">        <span class="comment">// 顺序：切分，流转，去重，转int，排序</span></span><br><span class="line">        Arrays.stream(s.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">                .distinct().map(Integer::parseInt).sorted((a,b)-&gt;b-a)</span><br><span class="line">                .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并流</span></span><br><span class="line">        Stream.concat(Stream.of(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>), Stream.of(<span class="number">2</span>, <span class="number">5</span>)).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="收集流对象"><a href="#收集流对象" class="headerlink" title="收集流对象"></a>收集流对象</h2><blockquote>
<p>一般用的最多的就是Stream提供的常用的两个收集方法。</p>
<p>首先</p>
<ul>
<li><code>将流中数据收集到数组中：流.toArray()</code></li>
<li><code>将流中数据收集到List集合中：流.collect(Collectors.tolist())</code></li>
<li><code>将流中数据收集到Set集合中：流.collect(Collectors.toSet())</code></li>
<li><code>将流中数据收集到Map集合中：流.collect(Collectors.toMap(lambda1, lambda2))</code></li>
</ul>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240227220105763.png" alt="image-20240227220105763"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习流的数据收集起来</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">collectStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 使用集合存一些字符串数据</span></span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,<span class="string">&quot;张翠山&quot;</span>,<span class="string">&quot;张无忌&quot;</span>,<span class="string">&quot;张翠花&quot;</span>,<span class="string">&quot;张翠翠&quot;</span>,<span class="string">&quot;战三&quot;</span>,<span class="string">&quot;华安&quot;</span>,<span class="string">&quot;张三丰&quot;</span>,<span class="string">&quot;张伟&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 筛选出姓张的人，并收集到数组中中</span></span><br><span class="line">        Object[] array = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).toArray();</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        <span class="comment">// 3, 筛选姓张的，放到set集合中/list列表 等单列集合中</span></span><br><span class="line">        List&lt;String&gt; list1 = list.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        <span class="comment">// 4, 使用全名当成map的key,姓氏当成map的value，将流中的数据收集到map集合中</span></span><br><span class="line">        <span class="comment">// toMap 方法需要传递两个Function接口类型的参数，分别告诉他元素如何转成key，如何转成value</span></span><br><span class="line">        Map&lt;String, Character&gt; collect = list.stream().collect(Collectors.toMap(s -&gt; s, s -&gt; s.charAt(<span class="number">0</span>)));</span><br><span class="line">        <span class="comment">// 上面如果不使用charat也可以用s -&gt; s.substring(0,1)</span></span><br><span class="line">        System.out.println(collect);</span><br><span class="line">        <span class="comment">// 5，将下面数组中的数据收集到map集合中，名称当成key，年龄当成value</span></span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;张三,18&quot;</span>,<span class="string">&quot;李四,20&quot;</span>,<span class="string">&quot;王五,22&quot;</span>&#125;;</span><br><span class="line">        Map&lt;String, String&gt; collect1 = Arrays.stream(arr).collect(Collectors.toMap(s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">0</span>], s -&gt; s.split(<span class="string">&quot;,&quot;</span>)[<span class="number">1</span>]));</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="文件File"><a href="#文件File" class="headerlink" title="文件File"></a>文件File</h1><blockquote>
<p>是Java专门用来操作文件或者文件夹的类，一般就是通过创建一个File类的对象来操作文件的本身。</p>
<p>Notice：可以操作文件的路径、大小信息、名称、创建、删除等，但是不能操作文件的内容。</p>
</blockquote>
<h2 id="三种获取File对象的方式"><a href="#三种获取File对象的方式" class="headerlink" title="三种获取File对象的方式"></a>三种获取File对象的方式</h2><ul>
<li><code>new File(文件完整路径)</code></li>
<li><code>new File(父路径, 子路径)</code></li>
<li><code>new File(父路径文件对象, 子路径)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习获取文件对象的三种方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getFileObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 完整路径创建File对象(不管实际文件存不存在，对象都能创建成功)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08\\1.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1);</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08\\2.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2);</span><br><span class="line">        System.out.println(f1.exists());  <span class="comment">// true</span></span><br><span class="line">        System.out.println(f2.exists());  <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 2, 两个参数创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08&quot;</span>, <span class="string">&quot;3.txt&quot;</span>);</span><br><span class="line">        System.out.println(f3);</span><br><span class="line">        System.out.println(f3.exists());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 上面创建文件的方式都是绝对路径，相对路径默认是从项目开始的(不准确)</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;day08\\1.txt&quot;</span>);</span><br><span class="line">        System.out.println(f4.exists());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Flie类常用方法-一"><a href="#Flie类常用方法-一" class="headerlink" title="Flie类常用方法(一)"></a>Flie类常用方法(一)</h2><blockquote>
<p>用的最多的方法：</p>
<ul>
<li>判断文件是否存在</li>
<li>判断是否为一个文件</li>
<li>获取文件的名称</li>
<li>获取绝对路径</li>
</ul>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240228222710876.png" alt="image-20240228222710876"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1， 创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;day08\\1.txt&quot;</span>);</span><br><span class="line">        System.out.println(f1.exists());</span><br><span class="line">        System.out.println(f1.isDirectory());</span><br><span class="line">        System.out.println(f1.isFile());</span><br><span class="line">        <span class="comment">// 2，获取文件名</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08&quot;</span>);</span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        System.out.println(f2.isDirectory());</span><br><span class="line">        <span class="comment">// 3, 获取长度</span></span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        <span class="comment">// 4, 最后修改时间</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(f1.lastModified()).toLocaleString());</span><br><span class="line">        System.out.println(f2.lastModified());</span><br><span class="line">        <span class="comment">// 5, 获取路径</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Flie类常用方法-二"><a href="#Flie类常用方法-二" class="headerlink" title="Flie类常用方法(二)"></a>Flie类常用方法(二)</h2><blockquote>
<p>这里主要是关于文件&#x2F;文件夹的创建和删除。</p>
<p>注意删除文件夹的时候，该文件夹必须为空才能够删除，否则就不能删除。(文件没有要求)</p>
</blockquote>
<h3 id="创建文件相关方法"><a href="#创建文件相关方法" class="headerlink" title="创建文件相关方法"></a>创建文件相关方法</h3><ul>
<li>创建一个新的空文件：createNewFile()</li>
<li>创建单级文件：mkdir()<ul>
<li>不得不说这不就是Shell吗（bushi</li>
</ul>
</li>
<li>创建多级文件夹：mkdirs()<ul>
<li>Shell创建多级文件夹就是加参数 -p</li>
</ul>
</li>
</ul>
<h3 id="删除文件相关方法"><a href="#删除文件相关方法" class="headerlink" title="删除文件相关方法"></a>删除文件相关方法</h3><ul>
<li>delete(): 删除文件，空文件夹</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习文件对象的创建和删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">commonMethod2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1，创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08\\a&quot;</span>);</span><br><span class="line">        System.out.println(f.mkdir());</span><br><span class="line">        <span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08\\aa\\bb\\cc&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 删除文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08\\aa\\cc\\2.txt&quot;</span>);</span><br><span class="line">        System.out.println(f2.delete());</span><br><span class="line">        <span class="comment">// 3, 删除多层文件夹</span></span><br><span class="line">        System.out.println(f.delete());  <span class="comment">// 删除单个文件夹(如果文件夹有东西的话也是删不掉的)</span></span><br><span class="line">        System.out.println(f3.delete());  <span class="comment">// 递归删除多层文件夹(必须是空文件夹)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h2><blockquote>
<p>遍历单层文件夹：File对象.listFiles()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习文件夹对象的遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">traverseDir</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1, 创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08\\aa&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 直接使用file对象调用listFile方法，得到这个文件夹下面所有的文件或者文件夹对象</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="comment">// 3, 遍历，获取aa下面的每一个字内容</span></span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="comment">// 打印字内容的绝对路径</span></span><br><span class="line">            System.out.println(f.getAbsolutePath());</span><br><span class="line">            f.delete();  <span class="comment">// 相当于循环删除aa 目录下面的内容</span></span><br><span class="line">        &#125;</span><br><span class="line">        file.delete();  <span class="comment">// 删除aa本身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="listFiles方法相关注意事项"><a href="#listFiles方法相关注意事项" class="headerlink" title="listFiles方法相关注意事项"></a>listFiles方法相关注意事项</h3><blockquote>
<p>注意标红的就好了。</p>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240302184314973.png" alt="image-20240302184314973"></p>
<h3 id="遍历多层文件及文件夹-※"><a href="#遍历多层文件及文件夹-※" class="headerlink" title="遍历多层文件及文件夹(※)"></a>遍历多层文件及文件夹(※)</h3><blockquote>
<p>需要使用到递归（递归两个重点：1，找规律；2，找出口）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用递归遍历某个文件夹，输出所有文件及文件夹的绝对路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">recursionDir</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1，创建文件夹对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day08\\src\\com\\xlkh&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 这里需要将递归遍历文件夹的方法封装成一个方法，方便函数调用函数，不能直接调用主函数吧</span></span><br><span class="line">        getSubFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getSubFiles</span><span class="params">(File file)</span>&#123;</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory())&#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">                getSubFiles(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">                System.out.println(f.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="附：递归-Recursion"><a href="#附：递归-Recursion" class="headerlink" title="附：递归(Recursion)"></a>附：递归(Recursion)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    上一个简单的案例，使用递归来求5的阶乘</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">recursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试递归方法好不好使</span></span><br><span class="line">        System.out.println(getFactorial(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getFactorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">// 1, 找规律 2, 找出口</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n * getFactorial(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="框架体系"><a href="#框架体系" class="headerlink" title="框架体系"></a>框架体系</h2><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240401215644411.png" alt="image-20240401215644411"></p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><code>常见的编码字符集如下：</code></p>
<ul>
<li><p>ASCII字符集(ASCII编码表)  仅包含数字,字母,特殊符号和数字的对应关系;</p>
</li>
<li><p>GBK 中国人规定的码表,规定了汉字与数字的对应关系,但是由于汉字较多,所以需要使用两个数字对应一个汉字,且第1个数字一定是负数;</p>
</li>
<li><p>Unicode  万国码表,收录了全球所有国家使用的符号,方便统一管理;</p>
<ul>
<li><p>UTF-32  unicode下的具体一种编码格式,规定所有符号都使用4个字节表示,比较浪费空间;</p>
</li>
<li><p>UTF-8    UTF-32的优化,尽可能少的占用字节,当能用更少的字节表示数据的时候,就采用少字节存储;在该编码格式下,一个汉字会占用3个字节;</p>
</li>
</ul>
</li>
</ul>
<p><code>支持中文的码表：GBK和UTF-8</code></p>
<h2 id="解码与编码"><a href="#解码与编码" class="headerlink" title="解码与编码"></a>解码与编码</h2><blockquote>
<ul>
<li><p>解码：把字符串变成数字的过程就是编码;</p>
<ul>
<li>可以利用String类中的getBytes方法完成;</li>
<li><code>例如：byte[] var = s.getBytes() - 其中s是字符串</code></li>
<li>同样也可以在getBytes方法内部指定字符集：<code>byte[] gbks = s.getBytes(&quot;gbk&quot;);</code></li>
</ul>
</li>
<li><p>把数字转成字符串的过程就是解码;</p>
<ul>
<li>可以利用String类的构造方法完成;</li>
<li>没有指定编码表的情况下，默认按照utf-8解码<code>String s1 = new String(arr); </code></li>
<li>指定编码<code>String s2 = new String(gbks);</code></li>
</ul>
</li>
<li><p>注意：编码时采用的码表必须和解码时采用的码表一致,否则会出现乱码现象;</p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习字符串类中：</span></span><br><span class="line"><span class="comment">        编码：把字符串编程二进制数字就是编码</span></span><br><span class="line"><span class="comment">        解码：把二进制数据转成字符串的过程就是解码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">charSetDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        <span class="comment">// 1, 编码 字符串 - 数字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;你好&quot;</span>;</span><br><span class="line">        <span class="comment">// 2, 编码 不传参数，默认是idea默认编码(utf-8)</span></span><br><span class="line">        <span class="type">byte</span>[] arr = s.getBytes();</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 编码的时候，也可以手动指定字符集(但是必须要抛出一个不支持编码的异常)</span></span><br><span class="line">        <span class="type">byte</span>[] gbks = s.getBytes(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        System.out.println(gbks);</span><br><span class="line">        <span class="comment">// 4, 解码 数字 --&gt; 字符串  利用构造方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);  <span class="comment">// 没有指定编码表的情况下，默认按照utf-8解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当上面解码出现乱码的情况，需要手动指定编码表解码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常见的IO流"><a href="#常见的IO流" class="headerlink" title="常见的IO流"></a>常见的IO流</h2><blockquote>
<p>IO流是什么？IO流就是专门负责操作文件或网络中数据的。</p>
<p>大致可以分为：</p>
<ul>
<li><p>字节输入流   顶层代表  InputStream</p>
<ul>
<li>以内存为基准，将来自磁盘&#x2F;网络中的数据以<code>字节</code>的形式读入到内存中</li>
</ul>
</li>
<li><p>字节输出流  顶层代表  OutputStream</p>
<ul>
<li>以内存为基准，把内存中的数据以<code>字节</code>写出到磁盘&#x2F;网络中</li>
</ul>
</li>
<li><p><code>字符输入流  顶层代表   Reader</code></p>
<ul>
<li>以内存为基准，将来自磁盘&#x2F;网络中的数据以<code>字符</code>的形式读入到内存中</li>
</ul>
</li>
<li><p><code>字符输出流  顶层代表  Writer</code></p>
<ul>
<li>以内存为基准，把内存中的数据以<code>字符</code>写出到磁盘&#x2F;网络中</li>
</ul>
</li>
</ul>
<p>因为以字节的形式需要考虑到很多关于编码和解码的问题，且转为字节不是非常方便。</p>
</blockquote>
<h3 id="文件字节输入流"><a href="#文件字节输入流" class="headerlink" title="文件字节输入流"></a>文件字节输入流</h3><blockquote>
<p>创建文件字节输入流的方式主要有两种</p>
<ul>
<li>首先创建文件，将文件对象传递进FileInputStream()类中，产生该类的对象。</li>
<li>第二种方式是直接通过FileInputStream将文件路径传递进去，生成字节输入流对象。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    逐个字节读取文件中的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">readFileThroughBytes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1， 提前准备一个文件，并根据文件路径，创建输入流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day09\\src\\com\\xlkh\\demo01_charSet\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2， 读取文件中的字节数字</span></span><br><span class="line">        <span class="comment">// System.out.println((char) fin.read());</span></span><br><span class="line">        <span class="comment">// System.out.println((char) fin.read());</span></span><br><span class="line">        <span class="comment">// System.out.println((char) fin.read());</span></span><br><span class="line">        <span class="comment">// System.out.println((char) fin.read());</span></span><br><span class="line">        <span class="comment">// System.o ut.println((char) fin.read());</span></span><br><span class="line">        <span class="comment">// System.out.println((char) fin.read());</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="comment">// 3,使用while循环按照字节读取文件，如果文件对象.read()返回了-1则表明读取到了文件的末尾</span></span><br><span class="line">        <span class="keyword">while</span> ((res = fin.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用数组以字节方式读取文件中的数据。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用数组以 字节输入流的方法读取数据 （拓展</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">arrayEnhance_ByteInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 为了读取文件的总字节数，可以先创建文件对象，再获取文件大小</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day09\\src\\com\\xlkh\\demo01_charSet\\a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1, 提前准备一个文件，并根据文件路径，创建输入流对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f);</span><br><span class="line">        <span class="comment">// 2, 为了提高读取数据的效率，可以提前准备一个数组，用于保存读取到的内容，当数组读满的时候，再操作这些数据即可</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>) f.length()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次读取arr数组长的数据，并将数据放到arr中</span></span><br><span class="line">        fin.read(arr);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在JDK9及其以后，可以使用readAllBytes()方法读取数据</span></span><br><span class="line">        <span class="type">byte</span>[] by = fin.readAllBytes();</span><br><span class="line">        System.out.println(Arrays.toString(by));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件字节输出流-FileOutputStream"><a href="#文件字节输出流-FileOutputStream" class="headerlink" title="文件字节输出流(FileOutputStream)"></a>文件字节输出流(FileOutputStream)</h3><blockquote>
<p>将字节输出到文件中，主要分为三步，首先将打开冰箱门，第二步放入大象….不好意思，串台了。</p>
<ul>
<li><p>创建对象：<code>new FileOutputStream(文件路径)</code></p>
<ul>
<li>构造方法不带boolean参数,表示如果文件不存在,则创建,如果文件存在,则清空内容;</li>
<li>构造方法带boolean参数(true),表示如果文件不存在,则创建,如果文件存在,则续写内容;<ul>
<li>new FileOutputStream(文件路径, true)；</li>
</ul>
</li>
</ul>
</li>
<li><p>调用方法,写数据：<code>文件对象.write()</code></p>
<ul>
<li><p>直接写码值;</p>
<ul>
<li><code>f.write(97) -&gt; a</code></li>
</ul>
</li>
<li><p>直接写字节数组;</p>
<ul>
<li><code>f.write(&quot;哈哈&quot;.getBytes())</code></li>
</ul>
</li>
<li><p>直接写字节数组的一部分</p>
<ul>
<li><code>f.write(arr, 1, 2)表示从arr数组(byte类型)的1下标开始，写两个字节;</code></li>
</ul>
</li>
</ul>
</li>
<li><p>释放资源</p>
<ul>
<li>作为输出流必须释放资源,使用 close方法即可;<ul>
<li>f.close();</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240313224349014.png" alt="image-20240313224349014"></p>
<h3 id="文件资源释放"><a href="#文件资源释放" class="headerlink" title="文件资源释放"></a>文件资源释放</h3><blockquote>
<p>两种方式进行文件资源释放：</p>
<p>try catch finally和try with resource</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">tryCatchFinally</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在try的外面声明变量，在try的里面赋值，</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fout = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day09\\src\\com\\xlkh\\demo03_tryWithResource\\b.txt&quot;</span>);</span><br><span class="line">            fout.write(<span class="number">97</span>);</span><br><span class="line">            <span class="comment">// 需要写字符串的时候，需要将字符串转成字节数组</span></span><br><span class="line">            fout.write(<span class="string">&quot;97&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;捕获到异常..&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论try里面的代码如何执行，finally一定会执行（除非退出虚拟机</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 由于close方法本身也声明抛出了一场，所以需要单独针对这个异常，再次处理</span></span><br><span class="line">                <span class="keyword">if</span> (fout != <span class="literal">null</span>)&#123;</span><br><span class="line">                    fout.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    简化释放资源的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">tryWithResource</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在try外面声明变量，在try里面赋值，目的是为了提升作用域，可以在finally代码块中国使用</span></span><br><span class="line">        <span class="comment">// 注意：资源必须实现了CloseAble接口，才可以放在try后面的小括号中</span></span><br><span class="line">        <span class="keyword">try</span>(<span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day09\\src\\com\\xlkh\\demo03_tryWithResource\\b.txt&quot;</span>))&#123;</span><br><span class="line">            fout.write(<span class="number">97</span>);</span><br><span class="line">            fout.write(<span class="string">&quot;97&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;catch...over!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字节流的应用"><a href="#字节流的应用" class="headerlink" title="字节流的应用"></a>字节流的应用</h2><h3 id="注意事项※"><a href="#注意事项※" class="headerlink" title="注意事项※"></a><code>注意事项</code>※</h3><blockquote>
<p>使用字节输入流读取数据的时候：字节输入流.read()</p>
<ul>
<li>如果知识单纯的f.read()，则f.read()的返回值是读取到字节的码值</li>
<li>如果是f.read(数组)，则返回的是读取到的字节的个数</li>
</ul>
</blockquote>
<h3 id="递归获取文件夹大小"><a href="#递归获取文件夹大小" class="headerlink" title="递归获取文件夹大小"></a>递归获取文件夹大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用递归求某个文件夹的大小：文件夹包括文件和文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">recursionGetDirSize</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\Diary&quot;</span>);</span><br><span class="line">        System.out.println(getTotalLength(dir));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getTotalLength</span><span class="params">(File dir)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">totalLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">                totalLength += file.length();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">dirlen</span> <span class="operator">=</span> getTotalLength(file);</span><br><span class="line">                <span class="comment">// 少加了文件夹及其下面所有文件的长度</span></span><br><span class="line">                totalLength += dirlen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="递归复制文件夹及其子目录"><a href="#递归复制文件夹及其子目录" class="headerlink" title="递归复制文件夹及其子目录"></a>递归复制文件夹及其子目录</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    递归复制某个文件夹及其下面的所有文件或文件夹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">recursionCopyDir</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建两个文件夹对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\opt\\Java\\就业班\\Java进阶课程\\day09-字符集、IO流（一）\\a&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">dstFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\opt\\Java\\就业班\\Java进阶课程\\day09-字符集、IO流（一）\\b&quot;</span>);</span><br><span class="line">        copyDir(srcFile, dstFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyDir</span><span class="params">(File src, File dst)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 传递两个参数（需要拷贝的源文件夹以及拷贝到的目的文件夹）来实现文件夹的复制</span></span><br><span class="line">        File[] files = src.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="comment">// 拼接目的文件/文件夹路径并创建File对象</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">dstFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dst, file.getName());</span><br><span class="line">            <span class="keyword">if</span> (file.isFile())&#123;</span><br><span class="line">                <span class="comment">// 如果是文件的话直接拷贝到目的文件夹</span></span><br><span class="line">                copyFile(file, dstFile);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是文件夹的话,需要在目的文件夹中创建该文件夹,然后递归拷贝文件夹下的内容</span></span><br><span class="line">                dstFile.mkdirs();</span><br><span class="line">                copyDir(file, dstFile);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile, File dstFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1，创建文件字节输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="comment">// 2, 创建字节输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">        <span class="comment">// 创建数组，用于存放数据</span></span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">while</span> ((count = fin.read(arr)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fout.write(arr, <span class="number">0</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="字符输入流"><a href="#字符输入流" class="headerlink" title="字符输入流"></a>字符输入流</h3><blockquote>
<p>常用的方法：</p>
<ul>
<li>FileReader对象.read()<ul>
<li>每次读取一个字符返回，如果没有字符则会返回-1</li>
</ul>
</li>
<li>FileReader对象.read(字符型数组)<ul>
<li>每次用字符数组读取数据，返回字符数组读取了多少字符，如果没有读到数据也会返回-1</li>
</ul>
</li>
</ul>
</blockquote>
<p>因为使用单个字符读取数据的方式会比较低效，使用的场景非常有限，一般都是使用数组进行数据读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符输入流 -- 使用字符数组读取数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">charArrReader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1, 创建文件字符输入流</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day09\\src\\com\\xlkh\\demo01_charSet\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 提前准备一个int类型的变量</span></span><br><span class="line">        <span class="type">int</span> count;</span><br><span class="line">        <span class="type">char</span>[] arr = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">8192</span>];</span><br><span class="line">        <span class="keyword">while</span> ((count = fr.read(arr)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr, <span class="number">0</span>, count));</span><br><span class="line">        &#125;</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符输出流"><a href="#字符输出流" class="headerlink" title="字符输出流"></a>字符输出流</h3><blockquote>
<p>常用的方法：</p>
<ul>
<li><p>构造方法：</p>
<ul>
<li>new FileWriter(File f)：使用文件对象创建字符输出流对象，<code>覆盖写入</code></li>
<li>new FileWriter(String filePath)：使用文件路径创建字符输出流对象， 同上</li>
<li>new FileWriter(File f, boolean true)：使用文件对象创建字符输出流对象，<code>追加写入</code></li>
<li>new FileWriter(String filePath, boolean true)：使用文件路径创建字符输出流对象，同上</li>
</ul>
</li>
<li><p>成员方法：</p>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240318224048727.png" alt="image-20240318224048727"></p>
</li>
</ul>
</blockquote>
<h2 id="字节缓冲流-了解"><a href="#字节缓冲流-了解" class="headerlink" title="字节缓冲流(了解)"></a>字节缓冲流(了解)</h2><ul>
<li><p>概述</p>
<ul>
<li>在字节基础流的基础上,封装了一个内置的数组而已;</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>提升基本流逐个字节复制文件的性能;</li>
</ul>
</li>
<li><p>结论</p>
<ul>
<li>基本的字节流配合自定义的数组性能最高!</li>
</ul>
</li>
</ul>
<h2 id="字符缓冲流-※"><a href="#字符缓冲流-※" class="headerlink" title="字符缓冲流(※)"></a>字符缓冲流(※)</h2><ul>
<li><p>概述</p>
<ul>
<li>专门针对字符流进行包装的流,不仅仅提升了循环读取单个字符的性能,还提供了特有方法(读一行和跨平台的换行);</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>提升字符操作性能;</li>
<li>提供特有方法,更方便读写文本数据;</li>
</ul>
</li>
<li><p>使用套路</p>
<ul>
<li>都是利用带一个基本流的构造方法创建对象;</li>
<li>直接调用特有方法即可;</li>
</ul>
</li>
</ul>
<h3 id="具体API"><a href="#具体API" class="headerlink" title="具体API"></a>具体API</h3><ul>
<li>BufferWriter(Writer r): 把低级的字符输出流包装成一个高级的缓冲字符输出管道，提高字符输出流写数据的性能<ul>
<li>特殊方法：public void newLine()<ul>
<li>好处：可以模拟不同平台的换行，从而实现写数据自带换行</li>
<li>Linux，Windows，MacOS换行都有一定区别。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">charBufferOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 准备基本的字符输入流</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 包装成字符输出缓冲流</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">        <span class="comment">// 3, 循环写数据，每次写完之后 换行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 写数据</span></span><br><span class="line">            bw.write(<span class="string">&quot;测试数据&quot;</span>+ i);</span><br><span class="line">            <span class="comment">// 换行</span></span><br><span class="line">            bw.newLine();</span><br><span class="line">            <span class="comment">// 刷新流</span></span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;over!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>BufferReader(Reader r): 把低级的字符输入流包装成字符缓冲输入流管道，提高字符输入流的性能<ul>
<li>特殊方法：public void readLine()<ul>
<li>读取一行数据返回，如果没有数据则会返回Null</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">charBufferInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 准备基本的字符输入流</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2, 把基本流包装成为缓冲流</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3, 逐行读取，每次循环读取到的结果都会封装成一个字符串，读到文件末尾会返回null</span></span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s=br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="缓冲流综合练习-对文件内容排序"><a href="#缓冲流综合练习-对文件内容排序" class="headerlink" title="缓冲流综合练习-对文件内容排序"></a>缓冲流综合练习-对文件内容排序</h2><blockquote>
<ul>
<li>文件 综合案例</li>
<li>需求说明：<ul>
<li>对某个文件的内容，按照内容自带的行号排好顺序</li>
</ul>
</li>
<li>分析：<ul>
<li>文件本身不能直接对内容排序，因此需要将文件的内容，读取到内存中，在内存中完成排序后，再重新写回文件即可<br>1，读取文件的时候，应该逐行读取数据<br>2，遇到空白行应该排除<br>3，读取的内容，应该存入到一个TreeSet集合，自定义排序规则<br>4，遍历set集合，把内容逐行写回文件即可</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">charStreamDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 创建一个文件对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\3_bak.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2， 创建字符流输入对象</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr);</span><br><span class="line">        <span class="comment">// 3, 读取数据, 并将数据放到一个TreeSet列表中，定义排序规则为每行数据的序号</span></span><br><span class="line">        TreeSet&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;((a,b) -&gt; Integer.parseInt(String.valueOf(a.charAt(<span class="number">0</span>))) - Integer.parseInt(String.valueOf(b.charAt(<span class="number">0</span>))));</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span> ((s = br.readLine())!= <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!s.isEmpty())&#123;</span><br><span class="line">                ts.add(s);</span><br><span class="line">                <span class="comment">//System.out.println(s.charAt(0));</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String t : ts) &#123;</span><br><span class="line">            System.out.println(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建字符输出流，将数据sink到本地的另一个文件中</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\test.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 创建字符缓冲输出流，可以使用newline方法</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">        <span class="keyword">for</span> (String t : ts) &#123;</span><br><span class="line">            bw.append(t);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            <span class="comment">// 写完要么关闭文件，要么直接写到指定行数的时候刷新一次，如果不刷新数据就会保留在内存中，不会到文件中</span></span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><ul>
<li><p>概述</p>
<ul>
<li>转换流就是专门负责将字节流转成字符流;</li>
</ul>
</li>
<li><p>为什么要转</p>
<ul>
<li>因为在将字节流转成字符流的时候,可以指定编码格式;</li>
</ul>
</li>
<li><p>如何转</p>
<ul>
<li>字节输入流,转成字符输入流:   InputStreamReader,构造方法中传递一个基本的字节输入流,再加一个编码表字符串即可;</li>
<li>字节输出流,转成字符输出流:   OutputStreamWriter,构造方法中传递一个基本的字节输出流,再加一个编码表字符串即可;</li>
</ul>
</li>
</ul>
<h3 id="参考代码–读"><a href="#参考代码–读" class="headerlink" title="参考代码–读"></a>参考代码–读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    转换流 就是将字节流转为字符流 因为在字节流转为字符流的时候可以指定编码格式</span></span><br><span class="line"><span class="comment">        但是在JDK11之后就不需要转了，因为字符流可以直接指定编码格式了</span></span><br><span class="line"><span class="comment">    练习在读取文件数据的时候，指定编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">converStreamRead</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 创建基本的字节输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\test.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 创建一个字符输入流 （采用默认编码 utf-8）</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fin);</span><br><span class="line">        <span class="comment">// 创建对象的时候，指定文件的编码格式为 GBK</span></span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fin, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">// 在jdk11之后，可以使用子类的构造方法，直接指定编码</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">isr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\test.txt&quot;</span>, Charset.forName(<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">        <span class="comment">// 3, 逐个字符读取</span></span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="comment">// 下面如果是单纯的InputStreamReader则会出现乱码，原因在于字符流没有和源文件的编码格式统一</span></span><br><span class="line">        <span class="comment">// 有两种解决方法：1，使用带有指定编码的字符输入流(jdk11后) 2，使用字符输入流的子类 FileReader 指定编码情况下读取数据</span></span><br><span class="line">        <span class="keyword">while</span> ((c = isr.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>) c);</span><br><span class="line">        &#125;</span><br><span class="line">        isr2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考代码–写"><a href="#参考代码–写" class="headerlink" title="参考代码–写"></a>参考代码–写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习写文件数据的时候,指定编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyOutputStreamWriter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1: 创建本的字节输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;day10_Teacher/file/5.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2: 创建一个字符输出流;(采用默认编码,utf-8)</span></span><br><span class="line">        <span class="comment">//OutputStreamWriter osw = new OutputStreamWriter(fout,&quot;GBK&quot;);</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;day10_Teacher/file/7.txt&quot;</span>,Charset.forName(<span class="string">&quot;GBK&quot;</span>));</span><br><span class="line">        <span class="comment">//在jdk11之后,可以使用子类的构造方法,直接指定编码了</span></span><br><span class="line">       <span class="comment">// 3: 将字符串直接写到硬盘</span></span><br><span class="line">        osw.write(<span class="string">&quot;6哈6&quot;</span>);</span><br><span class="line">        osw.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="打印流-PrintStream"><a href="#打印流-PrintStream" class="headerlink" title="打印流(PrintStream)"></a>打印流(PrintStream)</h2><ul>
<li><p>概述</p>
<ul>
<li>打印流就是专门负责将内存中的数据,写到指定的目的地的流;</li>
</ul>
</li>
<li><p>作用</p>
<ul>
<li>简化输出数据的代码;(想输出任意类型的内容,可以利用print方法直接输出即可,想换行,直接利用println方法即可);</li>
</ul>
</li>
<li><p>使用步骤</p>
<ul>
<li>创建打印流对象;</li>
<li>直接调用方法打印数据即可;</li>
<li>释放资源;</li>
</ul>
</li>
</ul>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240410222858623.png" alt="image-20240410222858623"></p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    字符打印流 和 字节打印流的效果一模一样，仅仅是字符打印流的构造方法，可以接收字节流， 二字节打印流不能封装字符流</span></span><br><span class="line"><span class="comment">        PrintStream 和 PrintWriter 的区别</span></span><br><span class="line"><span class="comment">        PrintStream继承自字节输出流OutputStream 因此支持字节数据的方法</span></span><br><span class="line"><span class="comment">        PrintWriter集成子字符输出流Writer 因此支持写字符数据出去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">printStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 创建字节打印流</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\a.txt&quot;</span>, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 直接向目的地打印数据(将字符97写到目的地，同时自动换行， 如果第一个参数是流，则不需要刷新，可以自动刷新</span></span><br><span class="line">        ps.println(<span class="number">97</span>);</span><br><span class="line">        ps.println(<span class="string">&quot;Java&quot;</span>);</span><br><span class="line">        ps.print(<span class="string">&quot;Python&quot;</span>);  <span class="comment">// 输出后没有换行</span></span><br><span class="line">        ps.println(<span class="number">18</span>);</span><br><span class="line">        ps.flush();</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><ul>
<li><p>概述</p>
<ul>
<li>可以把数据值传递的同时也可以携带该数据的数据类型;</li>
</ul>
</li>
<li><p>如何创建对象</p>
<ul>
<li>DataOutputStream:专门负责输出数据;</li>
<li>DataInputStream:专门负责读 DataOutputStream   曾经写的数据;</li>
<li>构造方法中都是封装了一个基本的字节流;</li>
</ul>
</li>
</ul>
<h3 id="常用方法-写"><a href="#常用方法-写" class="headerlink" title="常用方法-写"></a>常用方法-写</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240410223007154.png" alt="image-20240410223007154"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用数据流 最重要的特点就是 通过数据输入流和 输出流在写入(读取数据的时候)携带数据类型，只有Java能识别的数据类型</span></span><br><span class="line"><span class="comment">    数据流的基础是字节流※</span></span><br><span class="line"><span class="comment">    针对数据输出流的文件，应该配合数据输入流再读取一次，就可以把文件中保存的数据和数据类型读取到内存中了！！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myWriteDataStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 准备一个基本的字节输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\b.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 把基本流包装成数据流</span></span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(fout);</span><br><span class="line">        <span class="comment">// 3, 写数据的同时，携带数据类型</span></span><br><span class="line">        dop.writeByte(<span class="number">97</span>);</span><br><span class="line">        dop.writeInt(<span class="number">88</span>);</span><br><span class="line">        dop.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        dop.writeUTF(<span class="string">&quot;藕嫩叠&quot;</span>);</span><br><span class="line">        <span class="comment">// 4, 释放资源</span></span><br><span class="line">        dop.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用方法-读"><a href="#常用方法-读" class="headerlink" title="常用方法-读"></a>常用方法-读</h3><p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230526151102296.png" alt="image-20230526151102296"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myReadDataStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 准备一个基本的字节输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\b.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 包装成数据输入流</span></span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(fis);</span><br><span class="line">        <span class="comment">// 3, 读取带数据类型的数据</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> dis.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象流-序列化流"><a href="#对象流-序列化流" class="headerlink" title="对象流(序列化流)"></a>对象流(序列化流)</h2><ul>
<li><p>概述</p>
<ul>
<li>可以将java内存中的对象整体写到硬盘,也可以把硬盘上的对象,再读到内存中;</li>
</ul>
</li>
<li><p>类型</p>
<ul>
<li>写数据用: ObjectOutputStream ,(写数据的过程称为 序列化)</li>
<li>读数据用: ObjectInputStream ,   (读数据的过程称为 反序列化)</li>
</ul>
</li>
<li><p>构造方法</p>
<ul>
<li>里面都是包装一个基本的字节流;</li>
</ul>
</li>
<li><p>常用方法-写</p>
</li>
</ul>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230526154711745.png" alt="image-20230526154711745"></p>
<h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><ul>
<li>输出流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    对象输出流 也叫序列化流 意思就是将对象写到硬盘中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serializableOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 准备一个基本的字节输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\obj.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 包装成对象输出流</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        <span class="comment">// 3, 准备一个学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 4, 把学生对象存入硬盘(下面若想执行成功，则该对象必须实现了serializable接口，类似于深浅克隆中的Cloneable，打上了标记</span></span><br><span class="line">        oos.writeObject(s1);</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>输入流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">serializableInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 准备一个基本的字节输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day10\\src\\com\\xlkh\\obj.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2, 将基本字节流包装成对象输入流</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line">        <span class="comment">// 3, 直接读取数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="comment">// 如果读取到文件末尾，会出现异常，为了避免异常的发生，可以规定写数据的时候，把所有的对象都存入集合容器，则反序列化的时候，直接读取一次集合容器即可，然后遍历集合容器就可以避免异常发生</span></span><br><span class="line">        <span class="comment">// 这时，如果想直接调用getName和getAge方法则需要强转，因为成员方法，编译看左，运行看右，o父类对象中没有该方法，编译都不能通过</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&quot;-------&quot;</span> + s.getAge());</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><p>对象必须实现 Serializable 接口,否则无法序列化和反序列化!!!</p>
<p><img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20240410223411717.png" alt="image-20240410223411717"></p>
<h1 id="特殊文件的读取"><a href="#特殊文件的读取" class="headerlink" title="特殊文件的读取"></a>特殊文件的读取</h1><h2 id="properties"><a href="#properties" class="headerlink" title="properties"></a>properties</h2><blockquote>
<p>Properties 是代表属性的意思，在Java中常常用这种后缀类型的文件作为配置文件。</p>
<p>配置文件出来了，那必然是需要我们去读取的，如果用字符流读取可以但是没必要，用读取properties常用的方法往往无往而不利。</p>
</blockquote>
<h3 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h3><ul>
<li>定义：属于map中的一员,也是双列集合;</li>
</ul>
<p>类似于:</p>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20240404190204009.png" alt="image-20240404190204009"></p>
<ul>
<li><p>作用：专门与后缀名是properties的文件相互结合,可以方便的把集合中的数据存入文件,也能把文件中的数据读到集合中;</p>
</li>
<li><p>使用步骤</p>
<ul>
<li><p>利用构造方法创建对象;</p>
</li>
<li><p>利用成员方法,完成功能;</p>
</li>
</ul>
</li>
<li><p>构造方法</p>
</li>
</ul>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230528102525752.png" alt="image-20230528102525752"></p>
<ul>
<li>常用方法</li>
</ul>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230528102539935.png" alt="image-20230528102539935"></p>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230528103410774.png" alt="image-20230528103410774"></p>
<h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Properties 是Java中常见的配置文件，一般对于配置文件的读取都是遵循一定套路的，不会直接拿着字节流/字符流来读取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">myProperties</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 创建集合</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">// 2, 逐个添加数据</span></span><br><span class="line">        p.setProperty(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;11&quot;</span>);</span><br><span class="line">        p.setProperty(<span class="string">&quot;bb&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line">        p.setProperty(<span class="string">&quot;cc&quot;</span>, <span class="string">&quot;33&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="comment">// 单纯打印有点类似于Python中的字典：&#123;aa=11, bb=22, cc=33&#125;</span></span><br><span class="line">        <span class="comment">// 3, 直接读取某个文件中的数据到集合中(字符流和字节流都可以使用</span></span><br><span class="line">        <span class="comment">//FileReader fr = new FileReader(&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day11\\files\\2.properties&quot;);</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day11\\files\\2.properties&quot;</span>);</span><br><span class="line">        p.load(fr);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="comment">// 4, 根据key取值</span></span><br><span class="line">        System.out.println(p.getProperty(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 5, 获取所有的Key</span></span><br><span class="line">        Set&lt;String&gt; set = p.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String s : set) &#123;</span><br><span class="line">            System.out.println(s + <span class="string">&quot;----&gt;&quot;</span> + p.getProperty(s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><h3 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h3><p>是一门可扩展的标记语言;</p>
<ul>
<li><p>作用</p>
<ul>
<li>通过自定义的标记,存储或表示数据用的;通过开发中会使用xml文件当成系统的配置文件(存储着如何让程序运行的信息)使用;</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li><p>所有的内容都是由标签(标记)组成;</p>
</li>
<li><p>标签由 &lt; 自定义的名称 &gt;,必须有开头,由结尾;</p>
</li>
<li><p>文档的第一行第一列必须是固定的文档声明;   <?xml version="1.0" encoding="utf-8" ?></p>
</li>
<li><p>属性必须使用双引号包裹;</p>
</li>
<li><p>后缀名是xml</p>
</li>
<li><p>有且仅有一个根标签</p>
</li>
<li><p>标签嵌套不能交叉;</p>
</li>
</ul>
</li>
<li><p>注释</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注释  --&gt;</span><br><span class="line">如果有大量的转义字符,可以使用 CDATA区存;</span><br></pre></td></tr></table></figure>



<ul>
<li>xml文件演示</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!-- 这是注释 --&gt;</span><br><span class="line">&lt;abcd&gt;</span><br><span class="line">    &lt;aaa&gt;</span><br><span class="line">        &lt;b&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/b&gt;</span><br><span class="line">        &lt;<span class="type">b</span> <span class="variable">name</span> <span class="operator">=</span><span class="string">&quot;嘿嘿&quot;</span>&gt;</span><br><span class="line">            &amp;lt;为所欲为 &amp;gt;</span><br><span class="line">        &lt;/b&gt;</span><br><span class="line"></span><br><span class="line">        &lt;![CDATA[</span><br><span class="line">            &lt;水浒传&gt;</span><br><span class="line">            &lt;红楼梦&gt;</span><br><span class="line">            &lt;&lt;&lt;</span><br><span class="line">            &gt;&gt;&gt;</span><br><span class="line">            <span class="string">&#x27;</span></span><br><span class="line"><span class="string">            &quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ]]&gt;</span></span><br><span class="line"><span class="string">        &lt;bbb id=&quot;345&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;/aaa&gt;</span></span><br><span class="line"><span class="string">    &lt;b&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/b&gt;</span></span><br><span class="line"><span class="string">&lt;/abcd&gt;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>



<h3 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h3><blockquote>
<p>利用dom4j工具完成;</p>
</blockquote>
<p>使用步骤</p>
<ul>
<li><p>创建解析器</p>
</li>
<li><p>获取根</p>
</li>
<li><p>利用根对象,获取里面的所有字标签的集合</p>
</li>
<li><p>遍历集合即可获取每个子标签</p>
</li>
<li><p>面向每个字标签对象继续获取里面的属性,子标签的子标签,值等;</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!-- 这是注释 --&gt;</span><br><span class="line">&lt;stus&gt;</span><br><span class="line">    &lt;student id=<span class="string">&quot;1&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;张三&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">18</span>&lt;/age&gt;</span><br><span class="line">    &lt;/student&gt;</span><br><span class="line">    &lt;student id=<span class="string">&quot;2&quot;</span>&gt;</span><br><span class="line">        &lt;name&gt;李四&lt;/name&gt;</span><br><span class="line">        &lt;age&gt;<span class="number">19</span>&lt;/age&gt;</span><br><span class="line">    &lt;/student&gt;</span><br><span class="line">&lt;/stus&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用dom4j解析xml文本文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xmlParse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1, 利用空参数的构造方法， 创建一个解析器对象</span></span><br><span class="line">        <span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">        <span class="comment">// 2, 把整个xml读取成一个文档对象</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">d</span> <span class="operator">=</span> reader.read(<span class="string">&quot;C:\\Users\\admin\\Desktop\\opt\\Java\\day11\\files\\stu.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 3, 整个文档中，一定只有一个根，直接从文档对象中，获取根即可</span></span><br><span class="line">        <span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> d.getRootElement();</span><br><span class="line">        <span class="comment">// 4, 获取根下面的所有子标签</span></span><br><span class="line">        List&lt;Element&gt; stus = root.elements();</span><br><span class="line">        <span class="comment">// 5, 遍历集合，就可以获取到每一个具体的标签对象(Student标签</span></span><br><span class="line">        <span class="keyword">for</span> (Element stu : stus) &#123;</span><br><span class="line">            <span class="comment">// 5.1 面向每隔student标签对象，可以获取属性，也可以获取里面所有的子标签</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stu.attribute(<span class="string">&quot;id&quot;</span>).getValue();</span><br><span class="line">            System.out.println(<span class="string">&quot;id&quot;</span> + id);</span><br><span class="line">            <span class="comment">// 5.2 解析elem 标签对象 的子标签(各个学生属性</span></span><br><span class="line">            List&lt;Element&gt; prop = stu.elements();</span><br><span class="line">            <span class="comment">// 5.3 遍历prop获取每隔具体的标签对象（name，age</span></span><br><span class="line">            <span class="keyword">for</span> (Element name_age : prop) &#123;</span><br><span class="line">                <span class="comment">// 直接获取文本内容解渴</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> name_age.getText();</span><br><span class="line">                <span class="comment">// 获取标签的名称</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> name_age.getName();</span><br><span class="line">                System.out.println(name + <span class="string">&quot;标签下的内容是&quot;</span> + text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a>概述</h3><ul>
<li><p>定义：可以对xml文件的内容进行限制的技术;</p>
</li>
<li><p>作用</p>
<ul>
<li>dtd文件,可以对xml文件的内容进行粗粒度的限制;</li>
<li>xsd文件可以对xml文件的内容进行细粒度的限制;</li>
</ul>
</li>
<li><p>分类</p>
<ul>
<li><p>dtd约束,老的约束,粒度粗;</p>
</li>
<li><p>schema约束,新的约束技术,粒度细致;</p>
</li>
</ul>
</li>
<li><p>语法</p>
</li>
</ul>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230528144034307.png" alt="image-20230528144034307"></p>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230528144105130.png" alt="image-20230528144105130"></p>
<h3 id="xml和约束文件的引入方式"><a href="#xml和约束文件的引入方式" class="headerlink" title="xml和约束文件的引入方式"></a>xml和约束文件的引入方式</h3><p>dtd引入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 书架 SYSTEM <span class="string">&quot;data.dtd&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>xsd引入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;书架 xmlns=<span class="string">&quot;http://www.itcast.cn&quot;</span></span><br><span class="line">      xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">&quot;http://www.itcast.cn data.xsd&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>xml的内容,按照约束的提示写即可;</p>
<h1 id="日志及多线程三种实现方式"><a href="#日志及多线程三种实现方式" class="headerlink" title="日志及多线程三种实现方式"></a>日志及多线程三种实现方式</h1><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><ul>
<li><p>概述：专门用于记录程序运行的状态的技术;</p>
</li>
<li><p>常见日志框架</p>
<ul>
<li><p>logback</p>
</li>
<li><p>log4j</p>
</li>
</ul>
</li>
<li><p>logback的使用步骤</p>
<ul>
<li><p>环境级别:</p>
<ul>
<li>下载并复制jar包到idea;</li>
<li>复制配置文件到源码目录;</li>
</ul>
</li>
<li><p>代码级别:</p>
<ul>
<li>修改配置文件的内容;</li>
<li>获取一个日志对象;</li>
<li>面向对象,调用方法;</li>
</ul>
</li>
</ul>
</li>
<li><p>注意事项</p>
</li>
</ul>
<ol>
<li>配置文件的名称和路径必须按框架的要求写和存;(必须放在源码目录下且名称是  logback.xml)</li>
<li>获取日志对象的时候,注意包;</li>
</ol>
<h3 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    logback日志入门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLogBack</span> &#123;</span><br><span class="line">    <span class="comment">// 利用工具,获取一个日志对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG= LoggerFactory.getLogger(<span class="string">&quot;TestLogBack&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 利用 log对象 调用各种级别 的日志方法,就可以输出日志的内容了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;正常代码1&quot;</span>);</span><br><span class="line">        LOG.info(<span class="string">&quot;第一行代码走完了,没有出问题...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正常代码2&quot;</span>);</span><br><span class="line">        LOG.debug(<span class="string">&quot;第2行走完了,,,,debug级别&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正常代码3&quot;</span>);</span><br><span class="line">        LOG.error(<span class="string">&quot;严重问题,代码走完了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><ul>
<li><p>作用</p>
<ul>
<li>程序员可以通过设置不同的级别,从而决定记录程序中的不同问题;</li>
</ul>
</li>
<li><p>具体级别</p>
</li>
</ul>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230528161739165.png" alt="image-20230528161739165"></p>
<p>程序中会记录指定的级别以及更高的级别的问题!!!</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li><p>概述</p>
<ul>
<li>所谓的线程就是代码执行的通道;一个代码执行通道就是单线程程序,多个代码执行通道就是多线程程序;</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>多人聊天,多文件同时下载…等</li>
</ul>
</li>
<li><p>实现方式</p>
<ul>
<li>java中有3种方式可以实现多线程;</li>
</ul>
</li>
</ul>
<h4 id="方式1-继承Thread"><a href="#方式1-继承Thread" class="headerlink" title="方式1-继承Thread"></a>方式1-继承Thread</h4><ul>
<li><p>概述：Thread是java编写的专门用于描述线程的类,只要创建这个类的对象,或者继承这个线程类,我们就相当于拥有了一个线程对象了;</p>
</li>
<li><p>代码实现方式</p>
<ul>
<li>自定义一个类继承Thread类;</li>
<li>重写run方法,指定线程的任务;</li>
<li>在测试类中创建自定义类的对象并调用start方法启动线程即可;</li>
</ul>
</li>
</ul>
<h4 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    练习多线程的创建方式1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        继承  Thread类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法里面的代码,就是将来线程需要执行的   任务   (线程相当于是通道,马路),而run方法的内容就是这个通道内需要执行的代码,马路上的汽车</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我们自定义的线程打印了数据:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.demo05_Thread_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1: 创建线程对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 2: 让我们的线程执行起来,一旦m1这个线程启动成功了,无论m1线程内的任务是否执行完了,都不影响main方法继续往下执行其他的代码;</span></span><br><span class="line">        m1.start();</span><br><span class="line">        <span class="comment">// 3: 让main也打印100个数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;mian:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方式2-实现Runnable接口"><a href="#方式2-实现Runnable接口" class="headerlink" title="方式2-实现Runnable接口"></a>方式2-实现Runnable接口</h4><ul>
<li>概述<ul>
<li>我们自定义的类,实现接口,仅仅算术一个任务类,将来可以将该类的对象,作为线程的参数传递进去,让线程执行这个任务即可;</li>
</ul>
</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类目前只是一个任务类,等待线程执行它</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRun</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第二种方式创建的单纯的任务:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    利用java的Thread类,创建出一个线程对象,并将我们提前准备的任务对象,交给线程对象,让线程执行我们准备的任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1: 创建任务对象</span></span><br><span class="line">        <span class="type">MyRun</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line">        <span class="comment">// 2: 创建线程对象,,并将我们提前准备的任务对象,交给线程对象,让线程执行我们准备的任务</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(rw);</span><br><span class="line">        <span class="comment">// 3: 开启线程</span></span><br><span class="line">        t.start();</span><br><span class="line">        <span class="comment">// 4: mian执行任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;main:&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式3-实现Callable接口"><a href="#方式3-实现Callable接口" class="headerlink" title="方式3-实现Callable接口"></a>方式3-实现Callable接口</h4><ul>
<li><p>概述</p>
<ul>
<li>程序员可以写一个带返回值的任务类,只需要实现 Callable接口即可,但是这个接口无法直接和线程绑定,需要借助 FutureTask 类中转才可以,将来也可以面向 FutureTask 类的对象,获取线程的结果;</li>
</ul>
</li>
<li><p>FutureTask的常用方法</p>
</li>
</ul>
<p><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/image-20230528174125314.png" alt="image-20230528174125314"></p>
<h4 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    带返回值的任务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCall</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 模拟计算需要3秒的时间</span></span><br><span class="line">        System.out.println(<span class="string">&quot;模拟计算中....&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;模拟计算完....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 1: 创建带返回值的任务对象</span></span><br><span class="line">        <span class="type">MyCall</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCall</span>();</span><br><span class="line">        <span class="comment">// 2: 需要将my 任务对象包装成 FutureTask对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(my);</span><br><span class="line">        <span class="comment">// 3: 创建线程对象,并绑定 task</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;模拟main已经开启线程完毕...&quot;</span>);</span><br><span class="line">        <span class="comment">// 4: 找中间人要结果</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> task.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;mian得到的结果是:&quot;</span>+integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://liamjohnson-w.github.io">Johnson Liam</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://liamjohnson-w.github.io/2024/01/15/2024.01.15(%E8%BF%9B%E9%98%B6)/">https://liamjohnson-w.github.io/2024/01/15/2024.01.15(%E8%BF%9B%E9%98%B6)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/pic.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/16/2024.01.16/" title="【Java进阶】final及抽象类"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">【Java进阶】final及抽象类</div></div></a></div><div class="next-post pull-right"><a href="/2024/01/11/2024.01.11/" title="【Java进阶】Interface's Benefit(学生管理系统案例)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">【Java进阶】Interface's Benefit(学生管理系统案例)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/05/03/2023.04.24/" title="Java基础复习（上）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">Java基础复习（上）</div></div></a></div><div><a href="/2023/05/03/2023.04.26/" title="Java基础复习(下)双色球案例"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">Java基础复习(下)双色球案例</div></div></a></div><div><a href="/2023/05/03/2023.04.27/" title="Java面向对象"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-03</div><div class="title">Java面向对象</div></div></a></div><div><a href="/2023/05/28/2023.05.28/" title="【Java查漏补缺(一)】数组与循环"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-28</div><div class="title">【Java查漏补缺(一)】数组与循环</div></div></a></div><div><a href="/2023/06/22/2023.06.22/" title="【Java查漏补缺(二)】面向对象"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-22</div><div class="title">【Java查漏补缺(二)】面向对象</div></div></a></div><div><a href="/2023/07/04/2023.07.04/" title="【Java查漏补缺(三)】常用API之String"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-04</div><div class="title">【Java查漏补缺(三)】常用API之String</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/img/pic.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Johnson Liam</div><div class="author-info__description">机器都在学习,你有什么理由不学习?</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">224</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/weiswift/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/weiswift" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1265019024@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">网站由Github服务器托管,感谢支持！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.</span> <span class="toc-text">Static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">接口和多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-number">5.</span> <span class="toc-text">常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder"><span class="toc-number">5.1.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.3.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.4.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">5.1.5.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.2.</span> <span class="toc-text">StringBuilder应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Example1"><span class="toc-number">5.2.1.</span> <span class="toc-text">Example1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Example2"><span class="toc-number">5.2.2.</span> <span class="toc-text">Example2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringJoiner"><span class="toc-number">5.3.</span> <span class="toc-text">StringJoiner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">5.3.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.3.3.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.3.4.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-1"><span class="toc-number">5.3.5.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math"><span class="toc-number">5.4.</span> <span class="toc-text">Math</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">5.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2"><span class="toc-number">5.4.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-2"><span class="toc-number">5.4.3.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System"><span class="toc-number">5.5.</span> <span class="toc-text">System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">5.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-3"><span class="toc-number">5.5.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-3"><span class="toc-number">5.5.3.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runtime"><span class="toc-number">5.6.</span> <span class="toc-text">Runtime</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">5.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-4"><span class="toc-number">5.6.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-4"><span class="toc-number">5.6.3.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal"><span class="toc-number">5.7.</span> <span class="toc-text">BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">5.7.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number">5.7.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-1"><span class="toc-number">5.7.3.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">5.7.4.</span> <span class="toc-text">获取对象的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%EF%BC%88%E5%BF%85%E9%A1%BB%E8%A6%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.7.5.</span> <span class="toc-text">常用成员方法（必须要有对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-5"><span class="toc-number">5.7.6.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Notice-divide%E6%96%B9%E6%B3%95%E9%99%A4%E4%B8%8D%E5%B0%BD%E6%83%85%E5%86%B5"><span class="toc-number">5.8.</span> <span class="toc-text">Notice: divide方法除不尽情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CodeDemo"><span class="toc-number">5.8.1.</span> <span class="toc-text">CodeDemo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDk7%E6%97%A5%E6%9C%9F"><span class="toc-number">5.9.</span> <span class="toc-text">JDk7日期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date%E6%A6%82%E8%BF%B0"><span class="toc-number">5.9.1.</span> <span class="toc-text">Date概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-5"><span class="toc-number">5.9.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-6"><span class="toc-number">5.9.3.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK7%E7%9A%84%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">5.10.</span> <span class="toc-text">JDK7的日期格式化工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleDateFormat%E6%A6%82%E8%BF%B0"><span class="toc-number">5.10.1.</span> <span class="toc-text">SimpleDateFormat概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">5.10.2.</span> <span class="toc-text">如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-6"><span class="toc-number">5.10.3.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">5.10.3.1.</span> <span class="toc-text">格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">5.10.3.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calendar"><span class="toc-number">5.11.</span> <span class="toc-text">Calendar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">5.11.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-2"><span class="toc-number">5.11.2.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-7"><span class="toc-number">5.11.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-7"><span class="toc-number">5.11.4.</span> <span class="toc-text">代码案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDk7%E6%97%A5%E6%9C%9F-1"><span class="toc-number">6.1.</span> <span class="toc-text">JDk7日期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date%E6%A6%82%E8%BF%B0-1"><span class="toc-number">6.1.1.</span> <span class="toc-text">Date概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-8"><span class="toc-number">6.1.2.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-8"><span class="toc-number">6.1.3.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK7%E7%9A%84%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%B7%A5%E5%85%B7%E7%B1%BB-1"><span class="toc-number">6.2.</span> <span class="toc-text">JDK7的日期格式化工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SimpleDateFormat%E6%A6%82%E8%BF%B0-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">SimpleDateFormat概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-1"><span class="toc-number">6.2.2.</span> <span class="toc-text">如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-9"><span class="toc-number">6.2.3.</span> <span class="toc-text">常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96-1"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90-1"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Calendar-1"><span class="toc-number">6.3.</span> <span class="toc-text">Calendar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="toc-number">6.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-3"><span class="toc-number">6.3.2.</span> <span class="toc-text">使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-10"><span class="toc-number">6.3.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-9"><span class="toc-number">6.3.4.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK7%E5%92%8C8%E6%97%A5%E6%9C%9F%E7%B1%BB%E6%AF%94%E8%BE%83"><span class="toc-number">6.4.</span> <span class="toc-text">JDK7和8日期类比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">6.4.1.</span> <span class="toc-text">详细说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK8%E6%97%A5%E6%9C%9F"><span class="toc-number">6.5.</span> <span class="toc-text">JDK8日期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PART1"><span class="toc-number">6.5.1.</span> <span class="toc-text">PART1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDate%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">6.5.1.1.</span> <span class="toc-text">LocalDate类的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalTime%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">6.5.1.2.</span> <span class="toc-text">LocalTime类的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalDateTime%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">6.5.1.3.</span> <span class="toc-text">LocalDateTime类的基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ZoneId%E6%97%B6%E5%8C%BA"><span class="toc-number">6.5.1.4.</span> <span class="toc-text">ZoneId时区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="toc-number">6.5.1.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.1.4.2.</span> <span class="toc-text">获取方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.5.1.4.3.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-10"><span class="toc-number">6.5.1.4.4.</span> <span class="toc-text">代码案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PART2-Instant"><span class="toc-number">6.5.2.</span> <span class="toc-text">PART2(Instant)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95-1"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">获取方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-11"><span class="toc-number">6.5.2.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-11"><span class="toc-number">6.5.2.4.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PART3-DateTimeFormatter"><span class="toc-number">6.5.3.</span> <span class="toc-text">PART3(DateTimeFormatter)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-10"><span class="toc-number">6.5.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.3.2.</span> <span class="toc-text">获取方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.5.3.3.</span> <span class="toc-text">解析和格式化的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-12"><span class="toc-number">6.5.3.4.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PART4-Period-amp-Duration"><span class="toc-number">6.5.4.</span> <span class="toc-text">PART4(Period&amp;Duration)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-11"><span class="toc-number">6.5.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">6.5.4.2.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F-1"><span class="toc-number">6.5.4.3.</span> <span class="toc-text">获取方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.5.4.4.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-12"><span class="toc-number">6.5.4.5.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Period%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">6.5.4.6.</span> <span class="toc-text">Period代码案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Duration%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-number">6.5.4.7.</span> <span class="toc-text">Duration代码案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">7.1.</span> <span class="toc-text">Lambda表达式基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-13"><span class="toc-number">7.1.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Lambda%E7%AE%80%E5%8C%96%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.</span> <span class="toc-text">使用Lambda简化数组排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">7.2.1.</span> <span class="toc-text">基本类型数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-14"><span class="toc-number">7.2.1.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84"><span class="toc-number">7.2.2.</span> <span class="toc-text">泛型类型数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-15"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9C%81%E7%95%A5%E8%A7%84%E5%88%99-%E2%80%BB"><span class="toc-number">7.3.</span> <span class="toc-text">Lambda表达式省略规则(※)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-16"><span class="toc-number">7.3.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88Collection"><span class="toc-number">8.</span> <span class="toc-text">集合Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E6%B4%BE%E7%B3%BB-List-amp-Set"><span class="toc-number">8.1.</span> <span class="toc-text">单列集合派系(List&amp;Set)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.1.</span> <span class="toc-text">Collection集合常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-%E6%BC%94%E7%A4%BA%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">代码案例(演示常用方法)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E5%88%97%E8%A1%A8"><span class="toc-number">8.1.2.</span> <span class="toc-text">List列表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E9%9B%86%E5%90%88%E7%89%B9%E7%82%B9"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">ArrayList集合特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">LinkedList集合的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-%E5%A4%9A%E6%80%81"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">ArrayList代码案例(多态)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E9%9B%86%E5%90%88"><span class="toc-number">8.1.3.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashSet"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">8.1.3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">8.1.3.3.</span> <span class="toc-text">结论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Tips%EF%BC%9A"><span class="toc-number">8.1.3.3.1.</span> <span class="toc-text">Tips：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TreeSet"><span class="toc-number">8.1.3.4.</span> <span class="toc-text">TreeSet</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93"><span class="toc-number">8.1.4.</span> <span class="toc-text">单列集合总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%88%97%E7%BB%93%E5%90%88%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E6%96%97%E5%9C%B0%E4%B8%BB"><span class="toc-number">8.1.5.</span> <span class="toc-text">单列结合综合案例(斗地主)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-17"><span class="toc-number">8.1.5.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E6%B4%BE%E7%B3%BB-Map"><span class="toc-number">8.2.</span> <span class="toc-text">双列集合派系(Map)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB"><span class="toc-number">8.2.1.</span> <span class="toc-text">Map集合体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">Map集合常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-18"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E4%B9%8B-Entry"><span class="toc-number">8.2.3.</span> <span class="toc-text">双列集合之-Entry</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E6%A1%88%E4%BE%8B"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">具体操作案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88%E7%9A%84%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.4.</span> <span class="toc-text">Map集合的三种遍历方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-19"><span class="toc-number">8.2.4.1.</span> <span class="toc-text">代码案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%E7%BB%9F%E8%AE%A1%E8%AF%8D%E9%A2%91"><span class="toc-number">8.2.4.2.</span> <span class="toc-text">应用场景(统计词频)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-number">8.2.5.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedHashMap"><span class="toc-number">8.2.6.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap"><span class="toc-number">8.2.7.</span> <span class="toc-text">TreeMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97-%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86"><span class="toc-number">8.2.8.</span> <span class="toc-text">集合嵌套(三种遍历)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-12"><span class="toc-number">8.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F-2"><span class="toc-number">8.3.2.</span> <span class="toc-text">获取方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-13"><span class="toc-number">8.3.3.</span> <span class="toc-text">常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-20"><span class="toc-number">8.3.4.</span> <span class="toc-text">代码案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.3.5.</span> <span class="toc-text">迭代器使用注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.6.</span> <span class="toc-text">删除集合元素的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor"><span class="toc-number">8.4.</span> <span class="toc-text">增强for</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-amp-%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">8.4.1.</span> <span class="toc-text">概述&amp;实例演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%B8%AD%E4%B8%8ELambda%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">8.5.</span> <span class="toc-text">集合中与Lambda相关的两个方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach-lambda"><span class="toc-number">8.5.1.</span> <span class="toc-text">forEach(lambda)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#removeIf-lambda"><span class="toc-number">8.5.2.</span> <span class="toc-text">removeIf(lambda)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-21"><span class="toc-number">8.5.3.</span> <span class="toc-text">代码案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BBCollections"><span class="toc-number">9.</span> <span class="toc-text">集合工具类Collections</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">10.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-number">11.1.</span> <span class="toc-text">匹配单个字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%A4%9A%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-number">11.2.</span> <span class="toc-text">匹配多个字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E5%8C%B9%E9%85%8D"><span class="toc-number">11.3.</span> <span class="toc-text">分组匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-22"><span class="toc-number">11.4.</span> <span class="toc-text">代码案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="toc-number">11.4.1.</span> <span class="toc-text">验证数据是否正确</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E5%8F%96%E6%83%B3%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">11.4.2.</span> <span class="toc-text">提取想要的数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">12.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB"><span class="toc-number">12.1.</span> <span class="toc-text">异常的体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-1"><span class="toc-number">12.2.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">12.2.1.</span> <span class="toc-text">编译阶段的异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">12.2.2.</span> <span class="toc-text">运行阶段的异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">12.3.</span> <span class="toc-text">自定义异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8-%E9%9D%9E%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-number">12.3.1.</span> <span class="toc-text">运行时异常(非受检异常)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-23"><span class="toc-number">12.3.1.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8-%E5%8F%97%E6%A3%80%E5%BC%82%E5%B8%B8"><span class="toc-number">12.3.2.</span> <span class="toc-text">编译时异常(受检异常)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-24"><span class="toc-number">12.3.2.1.</span> <span class="toc-text">代码案例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Stream%E6%B5%81"><span class="toc-number">13.</span> <span class="toc-text">Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B5%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%83%85%E5%86%B5-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">13.1.</span> <span class="toc-text">获取流的四种情况(三种方式)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E7%BB%88%E7%BB%93%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">流的终结方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%9A%84%E4%B8%AD%E9%97%B4%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">流的中间方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B6%E9%9B%86%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.4.</span> <span class="toc-text">收集流对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6File"><span class="toc-number">14.</span> <span class="toc-text">文件File</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%8E%B7%E5%8F%96File%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">14.1.</span> <span class="toc-text">三种获取File对象的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flie%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E4%B8%80"><span class="toc-number">14.2.</span> <span class="toc-text">Flie类常用方法(一)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flie%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E4%BA%8C"><span class="toc-number">14.3.</span> <span class="toc-text">Flie类常用方法(二)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.1.</span> <span class="toc-text">创建文件相关方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.2.</span> <span class="toc-text">删除文件相关方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">14.4.</span> <span class="toc-text">遍历文件夹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#listFiles%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">14.4.1.</span> <span class="toc-text">listFiles方法相关注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%A4%9A%E5%B1%82%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9-%E2%80%BB"><span class="toc-number">14.4.2.</span> <span class="toc-text">遍历多层文件及文件夹(※)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%EF%BC%9A%E9%80%92%E5%BD%92-Recursion"><span class="toc-number">14.4.3.</span> <span class="toc-text">附：递归(Recursion)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">15.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">15.1.</span> <span class="toc-text">框架体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">15.2.</span> <span class="toc-text">字符集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">15.3.</span> <span class="toc-text">解码与编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%B5%81"><span class="toc-number">15.4.</span> <span class="toc-text">常见的IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">15.4.1.</span> <span class="toc-text">文件字节输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81-FileOutputStream"><span class="toc-number">15.4.2.</span> <span class="toc-text">文件字节输出流(FileOutputStream)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE"><span class="toc-number">15.4.3.</span> <span class="toc-text">文件资源释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">15.5.</span> <span class="toc-text">字节流的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E2%80%BB"><span class="toc-number">15.5.1.</span> <span class="toc-text">注意事项※</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F"><span class="toc-number">15.5.2.</span> <span class="toc-text">递归获取文件夹大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%8A%E5%85%B6%E5%AD%90%E7%9B%AE%E5%BD%95"><span class="toc-number">15.5.3.</span> <span class="toc-text">递归复制文件夹及其子目录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">15.6.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">15.6.1.</span> <span class="toc-text">字符输入流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">15.6.2.</span> <span class="toc-text">字符输出流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-number">15.7.</span> <span class="toc-text">字节缓冲流(了解)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81-%E2%80%BB"><span class="toc-number">15.8.</span> <span class="toc-text">字符缓冲流(※)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93API"><span class="toc-number">15.8.1.</span> <span class="toc-text">具体API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0-%E5%AF%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%8E%92%E5%BA%8F"><span class="toc-number">15.9.</span> <span class="toc-text">缓冲流综合练习-对文件内容排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">15.10.</span> <span class="toc-text">转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%E2%80%93%E8%AF%BB"><span class="toc-number">15.10.1.</span> <span class="toc-text">参考代码–读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81%E2%80%93%E5%86%99"><span class="toc-number">15.10.2.</span> <span class="toc-text">参考代码–写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81-PrintStream"><span class="toc-number">15.11.</span> <span class="toc-text">打印流(PrintStream)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81"><span class="toc-number">15.11.1.</span> <span class="toc-text">参考代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">15.12.</span> <span class="toc-text">数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E5%86%99"><span class="toc-number">15.12.1.</span> <span class="toc-text">常用方法-写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-%E8%AF%BB"><span class="toc-number">15.12.2.</span> <span class="toc-text">常用方法-读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81-%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">15.13.</span> <span class="toc-text">对象流(序列化流)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81-1"><span class="toc-number">15.13.1.</span> <span class="toc-text">参考代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">15.13.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-number">16.</span> <span class="toc-text">特殊文件的读取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#properties"><span class="toc-number">16.1.</span> <span class="toc-text">properties</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-13"><span class="toc-number">16.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81-2"><span class="toc-number">16.1.2.</span> <span class="toc-text">参考代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml"><span class="toc-number">16.2.</span> <span class="toc-text">xml</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-14"><span class="toc-number">16.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xml%E8%A7%A3%E6%9E%90"><span class="toc-number">16.2.2.</span> <span class="toc-text">xml解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">16.3.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-15"><span class="toc-number">16.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xml%E5%92%8C%E7%BA%A6%E6%9D%9F%E6%96%87%E4%BB%B6%E7%9A%84%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">16.3.2.</span> <span class="toc-text">xml和约束文件的引入方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">17.</span> <span class="toc-text">日志及多线程三种实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">17.1.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81-3"><span class="toc-number">17.1.1.</span> <span class="toc-text">参考代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="toc-number">17.1.2.</span> <span class="toc-text">日志级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">17.2.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F1-%E7%BB%A7%E6%89%BFThread"><span class="toc-number">17.2.0.1.</span> <span class="toc-text">方式1-继承Thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81-4"><span class="toc-number">17.2.0.2.</span> <span class="toc-text">参考代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.2.0.3.</span> <span class="toc-text">方式2-实现Runnable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">17.2.0.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F3-%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.2.0.5.</span> <span class="toc-text">方式3-实现Callable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E4%BB%A3%E7%A0%81-5"><span class="toc-number">17.2.0.6.</span> <span class="toc-text">参考代码</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" title="深度学习"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/24-07/cover7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深度学习"/></a><div class="content"><a class="title" href="/2025/06/17/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" title="深度学习">深度学习</a><time datetime="2025-06-16T16:00:00.000Z" title="Created 2025-06-17 00:00:00">2025-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/07/github-push%E5%87%BA%E9%94%99/" title="Github之Push问题解决方案"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/24-07/image-20250607224051237.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Github之Push问题解决方案"/></a><div class="content"><a class="title" href="/2025/06/07/github-push%E5%87%BA%E9%94%99/" title="Github之Push问题解决方案">Github之Push问题解决方案</a><time datetime="2025-06-06T16:00:00.000Z" title="Created 2025-06-07 00:00:00">2025-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" title="机器学习"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/24-07/image-20250605114200229.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习"/></a><div class="content"><a class="title" href="/2025/06/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/" title="机器学习">机器学习</a><time datetime="2025-06-03T16:00:00.000Z" title="Created 2025-06-04 00:00:00">2025-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/03/2025.06.03/" title="OLLAMA"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/24-07/image-20250603132906789.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OLLAMA"/></a><div class="content"><a class="title" href="/2025/06/03/2025.06.03/" title="OLLAMA">OLLAMA</a><time datetime="2025-06-02T16:00:00.000Z" title="Created 2025-06-03 00:00:00">2025-06-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/10/2025.05.10/" title="Mozi病毒样本分析"><img src="https://wei-blog.oss-cn-beijing.aliyuncs.com/24-07/image-20250604210840482.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Mozi病毒样本分析"/></a><div class="content"><a class="title" href="/2025/05/10/2025.05.10/" title="Mozi病毒样本分析">Mozi病毒样本分析</a><time datetime="2025-05-09T16:00:00.000Z" title="Created 2025-05-10 00:00:00">2025-05-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Johnson Liam</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Welcome to 小威の <a target="_blank" rel="noopener" href="https://www.cnblogs.com/liam-sliversucks/">Blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? '' : ''

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>